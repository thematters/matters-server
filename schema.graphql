directive @constraint(minLength: Int, maxLength: Int, startsWith: String, endsWith: String, contains: String, notContains: String, pattern: String, format: String, min: Float, max: Float, exclusiveMin: Float, exclusiveMax: Float, multipleOf: Float, minItems: Int, maxItems: Int, uniqueTypeName: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION | ARGUMENT_DEFINITION

directive @auth(mode: String!, group: String) on FIELD_DEFINITION

"""Rate limit within a given period of time, in seconds"""
directive @rateLimit(period: Int!, limit: Int!) on FIELD_DEFINITION

directive @privateCache(strict: Boolean! = false) on FIELD_DEFINITION

directive @objectCache(maxAge: Int = 1000) on FIELD_DEFINITION

directive @logCache(type: String!, identifier: String = "id") on FIELD_DEFINITION

directive @purgeCache(type: String!, identifier: String = "id") on FIELD_DEFINITION

directive @cacheControl(maxAge: Int, scope: CacheControlScope, inheritMaxAge: Boolean) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

directive @complexity(value: Int!, multipliers: [String!]) on FIELD_DEFINITION

type Query {
  article(input: ArticleInput!): Article
  circle(input: CircleInput!): Circle
  node(input: NodeInput!): Node
  nodes(input: NodesInput!): [Node!]
  frequentSearch(input: FrequentSearchInput!): [String!]
  search(input: SearchInput!): SearchResultConnection!
  official: Official!
  oss: OSS!
  viewer: User
  user(input: UserInput!): User
  oauthRequestToken: String
  exchangeRates(input: ExchangeRatesInput): [ExchangeRate!]
  oauthClient(input: OAuthClientInput!): OAuthClient
}

type Mutation {
  """Publish an article onto IPFS."""
  publishArticle(input: PublishArticleInput!): Draft!

  """Edit an article."""
  editArticle(input: EditArticleInput!): Article!

  """Subscribe or Unsubscribe article"""
  toggleSubscribeArticle(input: ToggleItemInput!): Article!

  """Appreciate an article."""
  appreciateArticle(input: AppreciateArticleInput!): Article!

  """Read an article."""
  readArticle(input: ReadArticleInput!): Article!

  """Follow or unfollow tag."""
  toggleFollowTag(input: ToggleItemInput!): Tag!

  """pin or unpin tag."""
  togglePinTag(input: ToggleItemInput!): Tag!

  """Create or update tag."""
  putTag(input: PutTagInput!): Tag!

  """Update member, permission and othters of a tag."""
  updateTagSetting(input: UpdateTagSettingInput!): Tag!

  """Add one tag to articles."""
  addArticlesTags(input: AddArticlesTagsInput!): Tag!

  """Update articles' tag."""
  updateArticlesTags(input: UpdateArticlesTagsInput!): Tag!

  """Delete one tag from articles"""
  deleteArticlesTags(input: DeleteArticlesTagsInput!): Tag!
  toggleArticleRecommend(input: ToggleRecommendInput!): Article!
  updateArticleState(input: UpdateArticleStateInput!): Article!
  updateArticleSensitive(input: UpdateArticleSensitiveInput!): Article!
  toggleTagRecommend(input: ToggleRecommendInput!): Tag!
  deleteTags(input: DeleteTagsInput!): Boolean
  renameTag(input: RenameTagInput!): Tag!
  mergeTags(input: MergeTagsInput!): Tag!

  """Create or update a Circle."""
  putCircle(input: PutCircleInput!): Circle!

  """Follow or unfollow a Circle."""
  toggleFollowCircle(input: ToggleItemInput!): Circle! @deprecated(reason: "No longer in use")

  """Subscribe a Circle."""
  subscribeCircle(input: SubscribeCircleInput!): SubscribeCircleResult!

  """Unsubscribe a Circle."""
  unsubscribeCircle(input: UnsubscribeCircleInput!): Circle!

  """Add or remove Circle's articles"""
  putCircleArticles(input: PutCircleArticlesInput!): Circle! @deprecated(reason: "No longer in use")

  """Invite others to join circle"""
  invite(input: InviteCircleInput!): [Invitation!]

  """Publish or update a comment."""
  putComment(input: PutCommentInput!): Comment!

  """Remove a comment."""
  deleteComment(input: DeleteCommentInput!): Comment!

  """Pin or Unpin a comment."""
  togglePinComment(input: ToggleItemInput!): Comment!

  """Upvote or downvote a comment."""
  voteComment(input: VoteCommentInput!): Comment!

  """Unvote a comment."""
  unvoteComment(input: UnvoteCommentInput!): Comment!

  """Update a comments' state."""
  updateCommentsState(input: UpdateCommentsStateInput!): [Comment!]!

  """Pin a comment."""
  pinComment(input: PinCommentInput!): Comment!

  """Unpin a comment."""
  unpinComment(input: UnpinCommentInput!): Comment!

  """Create or update a draft."""
  putDraft(input: PutDraftInput!): Draft!

  """Remove a draft."""
  deleteDraft(input: DeleteDraftInput!): Boolean

  """Mark all received notices as read."""
  markAllNoticesAsRead: Boolean

  """Upload a single file."""
  singleFileUpload(input: SingleFileUploadInput!): Asset!
  directImageUpload(input: DirectImageUploadInput!): Asset!

  """Add specific user behavior record."""
  logRecord(input: LogRecordInput!): Boolean

  """Add blocked search keyword to blocked_search_word db"""
  addBlockedSearchKeyword(input: KeywordInput!): BlockedSearchKeyword!

  """Delete blocked search keywords from search_history db"""
  deleteBlockedSearchKeywords(input: KeywordsInput!): Boolean

  """Submit inappropriate content report"""
  submitReport(input: SubmitReportInput!): Report!
  setBoost(input: SetBoostInput!): Node!
  putRemark(input: PutRemarkInput!): String
  putSkippedListItem(input: PutSkippedListItemInput!): [SkippedListItem!]
  setFeature(input: SetFeatureInput!): Feature!
  toggleSeedingUsers(input: ToggleSeedingUsersInput!): [User]!
  putAnnouncement(input: PutAnnouncementInput!): Announcement!
  deleteAnnouncements(input: DeleteAnnouncementsInput!): Boolean!
  putRestrictedUsers(input: PutRestrictedUsersInput!): [User!]!
  putIcymiTopic(input: PutIcymiTopicInput!): IcymiTopic

  """Send verification code for email."""
  sendVerificationCode(input: SendVerificationCodeInput!): Boolean

  """Confirm verification code from email."""
  confirmVerificationCode(input: ConfirmVerificationCodeInput!): ID!

  """Reset user or payment password."""
  resetPassword(input: ResetPasswordInput!): Boolean

  """Change user email."""
  changeEmail(input: ChangeEmailInput!): User! @deprecated(reason: "use 'setEmail' instead")

  """Set user email."""
  setEmail(input: SetEmailInput!): User!

  """Verify user email."""
  verifyEmail(input: VerifyEmailInput!): AuthResult!

  """Set user currency preference."""
  setCurrency(input: SetCurrencyInput!): User!

  """Register user, can only be used on matters.{town,news} website."""
  userRegister(input: UserRegisterInput!): AuthResult! @deprecated(reason: "use 'emailLogin' instead")

  """Login user."""
  userLogin(input: UserLoginInput!): AuthResult! @deprecated(reason: "use 'emailLogin' instead")
  emailLogin(input: EmailLoginInput!): AuthResult!

  """Get signing message."""
  generateSigningMessage(input: GenerateSigningMessageInput!): SigningMessageResult!

  """Login/Signup via a wallet."""
  walletLogin(input: WalletLoginInput!): AuthResult!

  """Add a wallet login to current user."""
  addWalletLogin(input: WalletLoginInput!): User!

  """Remove a wallet login from current user."""
  removeWalletLogin: User!

  """Login/Signup via social accounts."""
  socialLogin(input: SocialLoginInput!): AuthResult!

  """Add a social login to current user."""
  addSocialLogin(input: SocialLoginInput!): User!

  """Remove a social login from current user."""
  removeSocialLogin(input: RemoveSocialLoginInput!): User!

  """Reset crypto wallet."""
  resetWallet(input: ResetWalletInput!): User! @deprecated(reason: "use 'removeWalletLogin' instead")

  """Logout user."""
  userLogout: Boolean!

  """Generate or claim a Liker ID through LikeCoin"""
  generateLikerId: User! @deprecated(reason: "No longer in use")

  """Reset Liker ID"""
  resetLikerId(input: ResetLikerIdInput!): User!

  """Update user information."""
  updateUserInfo(input: UpdateUserInfoInput!): User!

  """Set user name."""
  setUserName(input: SetUserNameInput!): User!

  """Set user email login password."""
  setPassword(input: SetPasswordInput!): User!

  """Update user notification settings."""
  updateNotificationSetting(input: UpdateNotificationSettingInput!): User!

  """Follow or Unfollow current user."""
  toggleFollowUser(input: ToggleItemInput!): User!

  """Block or Unblock a given user."""
  toggleBlockUser(input: ToggleItemInput!): User!

  """Clear read history for user."""
  clearReadHistory(input: ClearReadHistoryInput!): User!

  """Clear search history for user."""
  clearSearchHistory: Boolean

  """Migrate articles from other service provider."""
  migration(input: MigrationInput!): Boolean

  """Let Traveloggers owner claims a Logbook, returns transaction hash"""
  claimLogbooks(input: ClaimLogbooksInput!): ClaimLogbooksResult!

  """update tags for showing on profile page"""
  putFeaturedTags(input: FeaturedTagsInput!): [Tag!]

  """Update state of a user, used in OSS."""
  updateUserState(input: UpdateUserStateInput!): [User!]

  """Update state of a user, used in OSS."""
  updateUserRole(input: UpdateUserRoleInput!): User!

  """Update referralCode of a user, used in OSS."""
  updateUserExtra(input: UpdateUserExtraInput!): User!

  """Update state of a user, used in OSS."""
  refreshIPNSFeed(input: RefreshIPNSFeedInput!): User!
  toggleUsersBadge(input: ToggleUsersBadgeInput!): [User]!
  unbindLikerId(input: UnbindLikerIdInput!): User!

  """Add Credit to User Wallet"""
  addCredit(input: AddCreditInput!): AddCreditResult!

  """Pay to another user or article"""
  payTo(input: PayToInput!): PayToResult!

  """Payout to user"""
  payout(input: PayoutInput!): Transaction!

  """Create Stripe Connect account for Payout"""
  connectStripeAccount(input: ConnectStripeAccountInput!): ConnectStripeAccountResult!

  """Create or Update an OAuth Client, used in OSS."""
  putOAuthClient(input: PutOAuthClientInput!): OAuthClient
  putCollection(input: PutCollectionInput!): Collection!
  deleteCollections(input: DeleteCollectionsInput!): Boolean!

  """Add articles to the begining of the collections."""
  addCollectionsArticles(input: AddCollectionsArticlesInput!): [Collection!]!

  """Remove articles from the collection."""
  deleteCollectionArticles(input: DeleteCollectionArticlesInput!): Collection!

  """Reorder articles in the collection."""
  reorderCollectionArticles(input: ReorderCollectionArticlesInput!): Collection!
}

"""
This type contains metadata, content, hash and related data of an article. If you
want information about article's comments. Please check Comment type.
"""
type Article implements Node & PinnableWork {
  """Unique ID of this article"""
  id: ID!

  """The number represents how popular is this article."""
  topicScore: Int

  """Slugified article title."""
  slug: String!

  """Time of this article was created."""
  createdAt: DateTime!

  """Time of this article was revised."""
  revisedAt: DateTime

  """State of this article."""
  state: ArticleState!

  """Author of this article."""
  author: User!

  """Article title."""
  title: String!

  """Article cover's link."""
  cover: String

  """
  List of assets are belonged to this article (Only the author can access currently).
  """
  assets: [Asset!]!

  """A short summary for this article."""
  summary: String!

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Tags attached to this article."""
  tags: [Tag!]

  """Word count of this article."""
  wordCount: Int

  """IPFS hash of this article."""
  dataHash: String!

  """Media hash, composed of cid encoding, of this article."""
  mediaHash: String!

  """Short hash for shorter url addressing"""
  shortHash: String!

  """Content (HTML) of this article."""
  content: String!

  """Different foramts of content."""
  contents: ArticleContents!

  """Original language of content"""
  language: String

  """List of articles which added this article into their collections."""
  collectedBy(input: ConnectionArgs!): ArticleConnection!

  """List of articles added into this article' collection."""
  collection(input: ConnectionArgs!): ArticleConnection!

  """Related articles to this article."""
  relatedArticles(input: ConnectionArgs!): ArticleConnection!

  """Donation-related articles to this article."""
  relatedDonationArticles(input: RelatedDonationArticlesInput!): ArticleConnection!

  """Appreciations history of this article."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciations recieved of this article."""
  appreciationsReceivedTotal: Int!

  """Total number of donation recieved of this article."""
  donationCount: Int!

  """Total number of readers of this article."""
  readerCount: Int!

  """Subscribers of this article."""
  subscribers(input: ConnectionArgs!): UserConnection!

  """Limit the nuhmber of appreciate per user."""
  appreciateLimit: Int!

  """Number represents how many times per user can appreciate this article."""
  appreciateLeft: Int!

  """This value determines if current viewer has appreciated or not."""
  hasAppreciate: Boolean!

  """This value determines if current viewer can SuperLike or not."""
  canSuperLike: Boolean!

  """This value determines if current Viewer has subscribed of not."""
  subscribed: Boolean!

  """
  This value determines if this article is an author selected article or not.
  """
  sticky: Boolean! @deprecated(reason: "Use pinned instead")
  pinned: Boolean!

  """Translation of article title and content."""
  translation(input: TranslationArgs): ArticleTranslation

  """Available translation languages."""
  availableTranslations: [UserLanguage!]

  """Transactions history of this article."""
  transactionsReceivedBy(input: TransactionsReceivedByArgs!): UserConnection!

  """Donations of this article, grouped by sender"""
  donations(input: ConnectionArgs!): ArticleDonationConnection!

  """Cumulative reading time in seconds"""
  readTime: Float!

  """Drafts linked to this article."""
  drafts: [Draft!] @deprecated(reason: "Use Article.newestUnpublishedDraft or Article.newestPublishedDraft instead")

  """Newest unpublished draft linked to this article."""
  newestUnpublishedDraft: Draft

  """Newest published draft linked to this article."""
  newestPublishedDraft: Draft!

  """Revision Count"""
  revisionCount: Int!

  """Access related fields on circle"""
  access: ArticleAccess!

  """whether content is marked as sensitive by author"""
  sensitiveByAuthor: Boolean!

  """whether content is marked as sensitive by admin"""
  sensitiveByAdmin: Boolean!

  """License Type"""
  license: ArticleLicenseType!

  """creator message asking for support"""
  donated: Boolean!

  """creator message asking for support"""
  requestForDonation: String

  """creator message after support"""
  replyToDonator: String

  """the iscnId if published to ISCN"""
  iscnId: String

  """whether readers can comment"""
  canComment: Boolean!

  """history versions"""
  versions(input: ArticleVersionsInput!): ArticleVersionsConnection!
  oss: ArticleOSS!
  remark: String

  """The counting number of comments."""
  commentCount: Int!

  """The number determines how many pinned comments can be set."""
  pinCommentLimit: Int!

  """The number determines how many comments can be set as pinned comment."""
  pinCommentLeft: Int!

  """List of pinned comments."""
  pinnedComments: [Comment!]

  """List of featured comments of this article."""
  featuredComments(input: FeaturedCommentsInput!): CommentConnection!

  """List of comments of this article."""
  comments(input: CommentsInput!): CommentConnection!

  """The counting number of this article."""
  responseCount: Int!

  """List of responses of a article."""
  responses(input: ResponsesInput!): ResponseConnection!
}

input ArticleVersionsInput {
  after: String
  first: Int
}

type ArticleVersionsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleVersionEdge]!
}

type ArticleVersionEdge {
  node: ArticleVersion!
  cursor: String!
}

type ArticleVersion implements Node {
  id: ID!
  dataHash: String
  mediaHash: String
  title: String!
  summary: String!
  contents: ArticleContents!
  translation(input: TranslationArgs): ArticleTranslation
  createdAt: DateTime!
  description: String
}

"""This type contains content, count and related data of an article tag."""
type Tag implements Node {
  """Unique id of this tag."""
  id: ID!

  """Content of this tag."""
  content: String!

  """List of how many articles were attached with this tag."""
  articles(input: TagArticlesInput!): ArticleConnection!

  """This value determines if this article is selected by this tag or not."""
  selected(input: TagSelectedInput!): Boolean!

  """Time of this tag was created."""
  createdAt: DateTime!

  """Tag's cover link."""
  cover: String

  """Description of this tag."""
  description: String

  """Editors of this tag."""
  editors(input: TagEditorsInput): [User!]

  """Creator of this tag."""
  creator: User

  """Owner of this tag."""
  owner: User

  """This value determines if current viewer is following or not."""
  isFollower: Boolean

  """This value determines if the tag is pinned by current viewer."""
  isPinned: Boolean

  """Followers of this tag."""
  followers(input: ConnectionArgs!): UserConnection!

  """Participants of this tag."""
  participants(input: ConnectionArgs!): UserConnection!

  """Tags recommended based on relations to current tag."""
  recommended(input: ConnectionArgs!): TagConnection!

  """This value determines if it is official."""
  isOfficial: Boolean

  """Counts of this tag."""
  numArticles: Int!
  numAuthors: Int!
  oss: TagOSS!
  remark: String
  deleted: Boolean!
}

type ArticleContents {
  """Markdown content of this article."""
  markdown: String!

  """HTML content of this article."""
  html: String!
}

type ArticleAccess {
  type: ArticleAccessType!
  secret: String
  circle: Circle
}

type ArticleOSS {
  boost: Float!
  score: Float!
  inRecommendIcymi: Boolean!
  inRecommendHottest: Boolean!
  inRecommendNewest: Boolean!
}

type ArticleTranslation {
  title: String
  content: String
  summary: String
  language: String
}

type TagOSS {
  boost: Float!
  score: Float!
  selected: Boolean!
}

type ArticleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleEdge!]
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

type TagConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TagEdge!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

type ArticleDonationConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleDonationEdge!]
}

type ArticleDonationEdge {
  cursor: String!
  node: ArticleDonation!
}

type ArticleDonation {
  id: ID!
  sender: User
}

input ArticleInput {
  mediaHash: String
  shortHash: String
}

input PublishArticleInput {
  id: ID!

  """whether publish to ISCN"""
  iscnPublish: Boolean
}

input EditArticleInput {
  id: ID!
  state: ArticleState

  """deprecated, use pinned instead"""
  sticky: Boolean
  pinned: Boolean
  title: String
  summary: String
  tags: [String!]
  content: String
  cover: ID
  collection: [ID!]
  circle: ID
  accessType: ArticleAccessType
  sensitive: Boolean
  license: ArticleLicenseType
  requestForDonation: String
  replyToDonator: String

  """revision description"""
  description: String

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean
}

input AppreciateArticleInput {
  id: ID!
  amount: Int!
  token: String
  superLike: Boolean
}

input ReadArticleInput {
  id: ID!
}

input ToggleRecommendInput {
  id: ID!
  enabled: Boolean!
  type: RecommendTypes
}

input UpdateArticleStateInput {
  id: ID!
  state: ArticleState!
}

input UpdateArticleSensitiveInput {
  id: ID!
  sensitive: Boolean!
}

input DeleteTagsInput {
  ids: [ID!]!
}

input RenameTagInput {
  id: ID!
  content: String!
}

input MergeTagsInput {
  ids: [ID!]!
  content: String!
}

input PutTagInput {
  id: ID
  content: String
  cover: ID
  description: String
}

input UpdateTagSettingInput {
  id: ID!
  type: UpdateTagSettingType!
  editors: [ID!]
}

input AddArticlesTagsInput {
  id: ID!
  articles: [ID!]
  selected: Boolean
}

input UpdateArticlesTagsInput {
  id: ID!
  articles: [ID!]
  isSelected: Boolean!
}

input DeleteArticlesTagsInput {
  id: ID!
  articles: [ID!]
}

enum TagArticlesSortBy {
  byHottestDesc
  byCreatedAtDesc
}

input TagArticlesInput {
  after: String
  first: Int
  oss: Boolean
  selected: Boolean
  sortBy: TagArticlesSortBy = byCreatedAtDesc
}

input TagSelectedInput {
  id: ID
  mediaHash: String
}

input TagEditorsInput {
  excludeAdmin: Boolean
  excludeOwner: Boolean
}

input TransactionsReceivedByArgs {
  after: String
  first: Int
  purpose: TransactionPurpose!
  senderId: ID
}

input TranslationArgs {
  language: UserLanguage!
}

input RelatedDonationArticlesInput {
  after: String
  first: Int
  oss: Boolean

  """index of article list, min: 0, max: 49"""
  random: Int
}

"""Enums for an article state."""
enum ArticleState {
  active
  archived
  banned
}

"""Enums for types of article access"""
enum ArticleAccessType {
  public
  paywall
}

"""Enums for types of article license"""
enum ArticleLicenseType {
  cc_0
  cc_by_nc_nd_2
  cc_by_nc_nd_4
  arr
}

"""Enums for types of recommend articles."""
enum RecommendTypes {
  icymi
  hottest
  newest
}

enum UpdateTagSettingType {
  adopt
  leave
  add_editor
  remove_editor
  leave_editor
}

type Circle implements Node {
  """Unique ID."""
  id: ID!

  """Circle avatar's link."""
  avatar: String @deprecated(reason: "No longer in use")

  """Circle cover's link."""
  cover: String @deprecated(reason: "No longer in use")

  """Slugified name of this Circle."""
  name: String! @deprecated(reason: "No longer in use")

  """Human readable name of this Circle."""
  displayName: String! @deprecated(reason: "No longer in use")

  """A short description of this Circle."""
  description: String

  """Prices offered by this Circle."""
  prices: [Price!]

  """Circle owner."""
  owner: User!

  """List of Circle member."""
  members(input: ConnectionArgs!): MemberConnection! @deprecated(reason: "No longer in use")

  """List of Circle follower."""
  followers(input: ConnectionArgs!): UserConnection! @deprecated(reason: "No longer in use")

  """List of works belong to this Circle."""
  works(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "No longer in use")

  """State of this Circle."""
  state: CircleState! @deprecated(reason: "No longer in use")

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is following Circle or not."""
  isFollower: Boolean! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is Member or not."""
  isMember: Boolean! @deprecated(reason: "No longer in use")

  """Invitations belonged to this Circle."""
  invites: Invites!

  """Invitation used by current viewer."""
  invitedBy: Invitation

  """Analytics dashboard."""
  analytics: CircleAnalytics!

  """Comments broadcasted by Circle owner."""
  broadcast(input: CommentsInput!): CommentConnection!

  """Pinned comments broadcasted by Circle owner."""
  pinnedBroadcast: [Comment!]

  """Comments made by Circle member."""
  discussion(input: CommentsInput!): CommentConnection!

  """Discussion (exclude replies) count of this circle."""
  discussionThreadCount: Int!

  """Discussion (include replies) count of this circle."""
  discussionCount: Int!
}

type User implements Node {
  """Circles belong to current user."""
  ownCircles: [Circle!]

  """Circles whiches user has subscribed."""
  subscribedCircles(input: ConnectionArgs!): CircleConnection!
  notices(input: ConnectionArgs!): NoticeConnection!

  """Global id of an user."""
  id: ID!

  """Global unique user name of a user."""
  userName: String

  """Display name on user profile, can be duplicated."""
  displayName: String

  """LikerID of LikeCoin, being used by LikeCoin OAuth"""
  likerId: String

  """Liker info of current user"""
  liker: Liker!

  """URL for user avatar."""
  avatar: String

  """User information."""
  info: UserInfo!

  """User settings."""
  settings: UserSettings!

  """Article recommendations for current user."""
  recommendation: Recommendation!

  """Articles authored by current user."""
  articles(input: UserArticlesInput!): ArticleConnection!

  """collections authored by current user."""
  collections(input: ConnectionArgs!): CollectionConnection!

  """user latest articles or collections"""
  latestWorks: [PinnableWork!]!

  """user pinned articles or collections"""
  pinnedWorks: [PinnableWork!]!

  """Tags by by usage order of current user."""
  tags(input: ConnectionArgs!): TagConnection!

  """Tags owned and maintained by current user."""
  maintainedTags(input: ConnectionArgs!): TagConnection!

  """Tags pinned by current user."""
  pinnedTags(input: ConnectionArgs!): TagConnection!

  """Drafts authored by current user."""
  drafts(input: ConnectionArgs!): DraftConnection!

  """Articles current user commented on"""
  commentedArticles(input: ConnectionArgs!): ArticleConnection!

  """Artilces current user subscribed to."""
  subscriptions(input: ConnectionArgs!): ArticleConnection!

  """Record of user activity, only accessable by current user."""
  activity: UserActivity!

  """Followers of this user."""
  followers(input: ConnectionArgs!): UserConnection!

  """Following contents of this user."""
  following: Following!

  """Whether current user is following viewer."""
  isFollower: Boolean!

  """Whether viewer is following current user."""
  isFollowee: Boolean!

  """Users that blocked by current user."""
  blockList(input: ConnectionArgs!): UserConnection!

  """Whether current user is blocking viewer."""
  isBlocking: Boolean!

  """Whether current user is blocked by viewer."""
  isBlocked: Boolean!

  """user data analytics, only accessable by current user."""
  analytics: UserAnalytics!

  """Status of current user."""
  status: UserStatus
  oss: UserOSS!
  remark: String

  """User Wallet"""
  wallet: Wallet!

  """Payment pointer that resolves to Open Payments endpoints"""
  paymentPointer: String
}

type Member {
  """User who join to a Circle."""
  user: User!

  """Price chosen by user when joining a Circle."""
  price: Price!
}

type Price {
  """Unique ID."""
  id: ID!

  """Amount of Price."""
  amount: Float!

  """Current Price belongs to whcih Circle."""
  circle: Circle!

  """Currency of Price."""
  currency: TransactionCurrency!

  """State of Price."""
  state: PriceState!

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")
}

type CircleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CircleEdge!]
}

type CircleEdge {
  cursor: String!
  node: Circle!
}

type MemberConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [MemberEdge!]
}

type MemberEdge {
  cursor: String!
  node: Member!
}

type SubscribeCircleResult {
  circle: Circle!

  """client secret for SetupIntent."""
  client_secret: String
}

type Invites {
  """Accepted invitation list"""
  accepted(input: ConnectionArgs!): InvitationConnection!

  """Pending invitation list"""
  pending(input: ConnectionArgs!): InvitationConnection!
}

type Invitation {
  """Unique ID."""
  id: ID!

  """Target person of this invitation."""
  invitee: Invitee!

  """Creator of this invitation."""
  inviter: User!

  """Invitation of current Circle."""
  circle: Circle!

  """Free period of this invitation."""
  freePeriod: Int!

  """Created time."""
  createdAt: DateTime!

  """Sent time."""
  sentAt: DateTime!

  """Accepted time."""
  acceptedAt: DateTime

  """Determine it's specific state."""
  state: InvitationState!
}

type Person {
  email: String!
}

union Invitee = Person | User

type InvitationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [InvitationEdge!]
}

type InvitationEdge {
  cursor: String!
  node: Invitation!
}

type CircleAnalytics {
  income: CircleIncomeAnalytics!
  subscriber: CircleSubscriberAnalytics!
  follower: CircleFollowerAnalytics!
  content: CircleContentAnalytics!
}

type CircleIncomeAnalytics {
  """income history of last 4 months"""
  history: [MonthlyDatum!]!

  """total income of all time"""
  total: Float!

  """income of this month"""
  thisMonth: Float!

  """income of next month"""
  nextMonth: Float!
}

type CircleSubscriberAnalytics {
  """subscriber count history of last 4 months"""
  subscriberHistory: [MonthlyDatum!]!

  """invitee count history of last 4 months"""
  inviteeHistory: [MonthlyDatum!]!

  """current subscriber count"""
  currentSubscriber: Int!

  """current invitee count"""
  currentInvitee: Int!
}

type CircleFollowerAnalytics {
  """subscriber count history of last 4 months"""
  history: [MonthlyDatum!]!

  """current follower count"""
  current: Int!

  """the percentage of follower count in reader count of circle articles"""
  followerPercentage: Float!
}

type CircleContentAnalytics {
  public: [CircleContentAnalyticsDatum!]
  paywall: [CircleContentAnalyticsDatum!]
}

type CircleContentAnalyticsDatum {
  node: Article!
  readCount: Int!
}

type MonthlyDatum {
  value: Float!
  date: DateTime!
}

input CircleInput {
  """Slugified name of a Circle."""
  name: String!
}

input PutCircleInput {
  """Unique ID."""
  id: ID

  """Unique ID of a Circle's avatar."""
  avatar: ID

  """Unique ID of a Circle's cover."""
  cover: ID

  """Slugified name of a Circle."""
  name: String

  """Human readable name of this Circle."""
  displayName: String

  """A short description of this Circle."""
  description: String

  """Circle's subscription fee."""
  amount: Float
}

input ToggleCircleMemberInput {
  """Unique ID."""
  id: ID!

  """Toggle value."""
  enabled: Boolean!

  """Unique ID of target user."""
  targetId: ID!
}

input SubscribeCircleInput {
  """Unique ID."""
  id: ID!

  """Wallet password."""
  password: String
}

input UnsubscribeCircleInput {
  """Unique ID."""
  id: ID!
}

input PutCircleArticlesInput {
  """Circle ID"""
  id: ID!

  """Article Ids"""
  articles: [ID!]

  """Action Type"""
  type: PutCircleArticlesType!

  """Access Type, `public` or `paywall` only."""
  accessType: ArticleAccessType!
  license: ArticleLicenseType
}

input InviteCircleInput {
  invitees: [InviteCircleInvitee!]!
  freePeriod: Int!
  circleId: ID!
}

input InviteCircleInvitee {
  id: ID
  email: String
}

enum CircleState {
  active
  archived
}

enum PriceState {
  active
  archived
}

enum PutCircleArticlesType {
  add
  remove
}

enum InvitationState {
  accepted
  pending
  transfer_succeeded
  transfer_failed
}

"""
This type contains content, author, descendant comments and related data of a comment.
"""
type Comment implements Node {
  """Unique ID of this comment."""
  id: ID!

  """State of this comment."""
  state: CommentState!
  type: CommentType!

  """Time of this comment was created."""
  createdAt: DateTime!

  """Content of this comment."""
  content: String

  """Author of this comment."""
  author: User!

  """This value determines this comment is pinned or not."""
  pinned: Boolean!

  """This value determines this comment is from article donator or not."""
  fromDonator: Boolean!

  """The counting number of upvotes."""
  upvotes: Int!

  """The counting number of downvotes."""
  downvotes: Int! @deprecated(reason: "No longer in use in querying")

  """The value determines current user's vote."""
  myVote: Vote

  """Descendant comments of this comment."""
  comments(input: CommentCommentsInput!): CommentConnection!

  """Parent comment of this comment."""
  parentComment: Comment

  """A Comment that this comment replied to."""
  replyTo: Comment
  remark: String

  """Current comment belongs to which Node."""
  node: Node!
}

type CommentConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CommentEdge!]
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input PutCommentInput {
  comment: CommentInput!
  id: ID
}

input CommentInput {
  content: String!
  replyTo: ID
  parentId: ID
  mentions: [ID!]
  type: CommentType!
  articleId: ID
  circleId: ID
}

input CommentCommentsInput {
  author: ID
  sort: CommentSort
  after: String
  first: Int
}

input CommentsInput {
  sort: CommentSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: Int
  filter: CommentsFilter
}

input FeaturedCommentsInput {
  sort: CommentSort
  after: String
  first: Int
}

input CommentsFilter {
  parentComment: ID
  state: CommentState
  author: ID
}

"""Enums for sorting comments by time."""
enum CommentSort {
  oldest
  newest
}

input PinCommentInput {
  id: ID!
}

input UnpinCommentInput {
  id: ID!
}

input DeleteCommentInput {
  id: ID!
}

input VoteCommentInput {
  vote: Vote!
  id: ID!
}

input UnvoteCommentInput {
  id: ID!
}

input UpdateCommentsStateInput {
  ids: [ID!]!
  state: CommentState!
}

"""Enums for vote types."""
enum Vote {
  up
  down
}

"""Enums for comment state."""
enum CommentState {
  active
  archived
  banned
  collapsed
}

enum CommentType {
  article
  circleDiscussion
  circleBroadcast
}

"""
This type contains content, collections, assets and related data of a draft.
"""
type Draft implements Node {
  """Unique ID of this draft."""
  id: ID!

  """Media hash, composed of cid encoding, of this draft."""
  mediaHash: String

  """Draft title."""
  title: String

  """Slugified draft title."""
  slug: String!

  """Summary of this draft."""
  summary: String

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Content (HTML) of this draft."""
  content: String

  """Time of this draft was created."""
  createdAt: DateTime!

  """Last time of this draft was upadted."""
  updatedAt: DateTime!

  """The counting number of words in this draft."""
  wordCount: Int!

  """Tags are attached to this draft."""
  tags: [String!]

  """Draft's cover link."""
  cover: String

  """State of draft during publihsing."""
  publishState: PublishState!

  """List of assets are belonged to this draft."""
  assets: [Asset!]!

  """Published article"""
  article: Article

  """Collection list of this draft."""
  collection(input: ConnectionArgs!): ArticleConnection!

  """Access related fields on circle"""
  access: DraftAccess!

  """whether content is marked as sensitive by author"""
  sensitiveByAuthor: Boolean!

  """License Type"""
  license: ArticleLicenseType!

  """creator message asking for support"""
  requestForDonation: String

  """creator message after support"""
  replyToDonator: String

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean!
}

type DraftConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DraftEdge!]
}

type DraftEdge {
  cursor: String!
  node: Draft!
}

type DraftAccess {
  type: ArticleAccessType!
  circle: Circle
}

input PutDraftInput {
  id: ID
  title: String
  summary: String
  content: String
  tags: [String!]
  cover: ID
  collection: [ID]
  circle: ID
  accessType: ArticleAccessType
  sensitive: Boolean
  license: ArticleLicenseType
  requestForDonation: String
  replyToDonator: String

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean
}

input DeleteDraftInput {
  id: ID!
}

"""Enums for publishing state."""
enum PublishState {
  unpublished
  pending
  error
  published
}

"""This interface contains common fields of a notice."""
interface Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!
}

type NoticeConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [NoticeEdge!]
}

type NoticeEdge {
  cursor: String!
  node: Notice!
}

type UserNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: UserNoticeType!
  target: User!
}

enum UserNoticeType {
  UserNewFollower
}

type ArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleNoticeType!
  target: Article!
}

enum ArticleNoticeType {
  ArticlePublished
  ArticleMentionedYou
  ArticleNewSubscriber
  ArticleNewAppreciation
  RevisedArticlePublished
  RevisedArticleNotPublished
  CircleNewArticle
}

type ArticleArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleArticleNoticeType!
  target: Article!
  article: Article!
}

enum ArticleArticleNoticeType {
  ArticleNewCollected
}

type CommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentNoticeType!
  target: Comment!
}

enum CommentNoticeType {
  CommentPinned
  CommentMentionedYou
  ArticleNewComment
  SubscribedArticleNewComment
  CircleNewBroadcast
}

type CommentCommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentCommentNoticeType!
  target: Comment!
  comment: Comment!
}

enum CommentCommentNoticeType {
  CommentNewReply
}

type TransactionNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: TransactionNoticeType!
  target: Transaction!
}

enum TransactionNoticeType {
  PaymentReceivedDonation
}

type CircleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CircleNoticeType!
  target: Circle!

  """Optional discussion/broadcast comments for bundled notices"""
  comments: [Comment!]

  """Optional discussion/broadcast replies for bundled notices"""
  replies: [Comment!]

  """Optional mention comments for bundled notices"""
  mentions: [Comment!]
}

enum CircleNoticeType {
  CircleInvitation
  CircleNewSubscriber
  CircleNewFollower
  CircleNewUnsubscriber
  CircleNewBroadcastComments
  CircleNewDiscussionComments
}

"""The notice type contains info about official announcement."""
type OfficialAnnouncementNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """The message content."""
  message: String!

  """The link to a specific page if provided."""
  link: String
}

scalar DateTime

scalar Upload

input KeywordsInput {
  keywords: [String!]
}

input KeywordInput {
  keyword: String!
}

interface Node {
  id: ID!
}

interface PinnableWork {
  id: ID!
  pinned: Boolean!
  title: String!
  cover: String
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

interface Connection {
  totalCount: Int!
  pageInfo: PageInfo!
}

type BlockedSearchKeyword {
  """Unique ID of bloked search keyword."""
  id: ID!

  """Types of this search keyword."""
  searchKey: String!

  """Time of this search keyword was created."""
  createdAt: DateTime!
}

"""This type contains system-wise info and settings."""
type Official {
  """Feature flag"""
  features: [Feature!]!

  """Announcements"""
  announcements(input: AnnouncementsInput!): [Announcement!]
}

type Feature {
  name: FeatureName!
  enabled: Boolean!
}

type Announcement {
  id: ID!
  title: String
  cover: String
  content: String
  link: String
  type: AnnouncementType!
  visible: Boolean!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  expiredAt: DateTime
  translations: [TranslatedAnnouncement!]
}

type TranslatedAnnouncement {
  language: UserLanguage!
  title: String
  cover: String
  content: String
  link: String
}

type OSS {
  users(input: ConnectionArgs!): UserConnection!
  comments(input: ConnectionArgs!): CommentConnection!
  articles(input: ConnectionArgs!): ArticleConnection!
  tags(input: TagsInput!): TagConnection!
  oauthClients(input: ConnectionArgs!): OAuthClientConnection!
  skippedListItems(input: SkippedListItemsInput!): SkippedListItemsConnection!
  seedingUsers(input: ConnectionArgs!): UserConnection!
  badgedUsers(input: BadgedUsersInput!): UserConnection!
  restrictedUsers(input: ConnectionArgs!): UserConnection!
  reports(input: ConnectionArgs!): ReportConnection!
  icymiTopics(input: ConnectionArgs!): IcymiTopicConnection!
}

"""This type contains type, link and related data of an asset."""
type Asset {
  """Unique ID of this Asset."""
  id: ID!

  """Types of this asset."""
  type: AssetType!

  """Link of this asset."""
  path: String!
  draft: Boolean
  uploadURL: String

  """Time of this asset was created."""
  createdAt: DateTime!
}

type SearchResultConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SearchResultEdge!]
}

type SearchResultEdge {
  cursor: String!
  node: Node!
}

input TagsInput {
  after: String
  first: Int
  sort: TagsSort
}

input SkippedListItemsInput {
  after: String
  first: Int
  type: SkippedListItemType
}

input BadgedUsersInput {
  after: String
  first: Int
  type: BadgeType
}

type SkippedListItemsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SkippedListItemEdge!]
}

type SkippedListItemEdge {
  cursor: String!
  node: SkippedListItem
}

type SkippedListItem {
  id: ID!
  uuid: ID!
  type: SkippedListItemType!
  value: String!
  archived: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserRestriction {
  type: UserRestrictionType!
  createdAt: DateTime!
}

type Report implements Node {
  id: ID!
  reporter: User!
  target: Response!
  reason: ReportReason!
  createdAt: DateTime!
}

type ReportConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ReportEdge!]
}

type ReportEdge {
  cursor: String!
  node: Report!
}

input NodeInput {
  id: ID!
}

input NodesInput {
  ids: [ID!]!
}

input FrequentSearchInput {
  key: String
  first: Int
}

input SearchInput {
  """search keyword"""
  key: String!

  """types of search target"""
  type: SearchTypes!
  after: String
  first: Int

  """extra query filter for searching"""
  filter: SearchFilter

  """specific condition for rule data out"""
  exclude: SearchExclude

  """should include tags used by author"""
  includeAuthorTags: Boolean

  """whether this search operation should be recorded in search history"""
  record: Boolean
  oss: Boolean

  """use the api version; default to use latest stable version is v20230301"""
  version: SearchAPIVersion = v20230301

  """deprecated, make no effect"""
  coefficients: String
  quicksearch: Boolean
}

input SearchFilter {
  authorId: ID
}

input SingleFileUploadInput {
  type: AssetType!
  file: Upload
  url: String
  draft: Boolean
  entityType: EntityType!
  entityId: ID
}

input DirectImageUploadInput {
  type: AssetType!
  mime: String
  url: String
  draft: Boolean
  entityType: EntityType!
  entityId: ID
}

input SetBoostInput {
  id: ID!
  boost: Float!
  type: BoostTypes!
}

input PutRemarkInput {
  id: ID!
  remark: String!
  type: RemarkTypes!
}

input PutSkippedListItemInput {
  id: ID
  type: SkippedListItemType
  value: String
  archived: Boolean
}

input LogRecordInput {
  type: LogRecordTypes!
}

input ConnectionArgs {
  after: String
  first: Int
  oss: Boolean
  filter: FilterInput
}

"""Common input to toggle single item for `toggleXXX` mutations"""
input ToggleItemInput {
  id: ID!
  enabled: Boolean
}

input SetFeatureInput {
  name: FeatureName!
  flag: FeatureFlag!
}

input ToggleSeedingUsersInput {
  ids: [ID!]
  enabled: Boolean!
}

input AnnouncementsInput {
  id: ID
  visible: Boolean
}

input TranslatedAnnouncementInput {
  language: UserLanguage!
  title: String
  cover: String
  content: String
  link: String
}

input PutAnnouncementInput {
  id: ID
  title: String
  cover: String
  content: String
  link: String
  type: AnnouncementType
  expiredAt: DateTime
  visible: Boolean
  order: Int
  translations: [TranslatedAnnouncementInput!]
}

input DeleteAnnouncementsInput {
  ids: [ID!]
}

input PutRestrictedUsersInput {
  ids: [ID!]!
  restrictions: [UserRestrictionType!]!
}

input SubmitReportInput {
  targetId: ID!
  reason: ReportReason!
}

enum SearchTypes {
  Article
  User
  Tag
}

enum SearchAPIVersion {
  v20230601
  v20230301
}

enum BoostTypes {
  Article
  User
  Tag
}

enum RemarkTypes {
  Article
  User
  Tag
  Comment
  Report
  Feedback
}

enum LogRecordTypes {
  ReadFolloweeArticles
  ReadFollowingFeed
  ReadResponseInfoPopUp
}

"""Enums for sorting tags."""
enum TagsSort {
  newest
  oldest
  hottest
}

"""Enums for asset types."""
enum AssetType {
  avatar
  cover
  embed
  embedaudio
  profileCover
  oauthClientAvatar
  tagCover
  circleAvatar
  circleCover
  collectionCover
  announcementCover
}

enum EntityType {
  article
  draft
  tag
  user
  circle
  announcement
  collection
}

"""Enums for user roles."""
enum Role {
  vistor
  user
  admin
}

enum SkippedListItemType {
  agent_hash
  email
  domain
}

enum FeatureName {
  add_credit
  payment
  payout
  verify_appreciate
  fingerprint
  tag_adoption
  circle_management
  circle_interact
}

enum FeatureFlag {
  on
  off
  admin
  seeding
}

enum SearchExclude {
  blocked
}

enum AnnouncementType {
  community
  product
  seminar
}

enum UserRestrictionType {
  articleHottest
  articleNewest
}

enum ReportReason {
  tort
  illegal_advertising
  discrimination_insult_hatred
  pornography_involving_minors
  other
}

type IcymiTopic implements Node {
  id: ID!
  title: String!
  articles: [Article!]!
  pinAmount: Int!
  note: String
  state: IcymiTopicState!
  publishedAt: DateTime
  archivedAt: DateTime
}

enum IcymiTopicState {
  published
  editing
  archived
}

type IcymiTopicConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [IcymiTopicEdge!]!
}

type IcymiTopicEdge {
  cursor: String!
  node: IcymiTopic!
}

input PutIcymiTopicInput {
  id: ID
  title: String
  articles: [ID!]
  pinAmount: Int
  note: String
  state: IcymiTopicState
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

type Recommendation {
  """Activities based on user's following, sort by creation time."""
  following(input: ConnectionArgs!): FollowingActivityConnection!

  """Articles recommended based on recently read article tags."""
  readTagsArticles(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "Merged into following")

  """Global articles sort by publish time."""
  newest(input: ConnectionArgs!): ArticleConnection!

  """Global articles sort by latest activity time."""
  hottest(input: ConnectionArgs!): ArticleConnection!

  """'In case you missed it' recommendation."""
  icymi(input: ConnectionArgs!): ArticleConnection!

  """'In case you missed it' topic."""
  icymiTopic: IcymiTopic

  """Global tag list, sort by activities in recent 14 days."""
  tags(input: RecommendInput!): TagConnection!

  """Hottest tag list"""
  hottestTags(input: RecommendInput!): TagConnection!

  """Selected tag list"""
  selectedTags(input: RecommendInput!): TagConnection!

  """Global user list, sort by activities in recent 6 month."""
  authors(input: RecommendInput!): UserConnection!

  """Global circles sort by created time."""
  newestCircles(input: ConnectionArgs!): CircleConnection!

  """Global circles sort by latest activity time."""
  hottestCircles(input: ConnectionArgs!): CircleConnection!
}

input RecommendInput {
  after: String
  first: Int
  oss: Boolean
  filter: FilterInput
  type: AuthorsType
}

input FilterInput {
  """index of list, min: 0, max: 49"""
  random: Int

  """Used in RecommendInput"""
  followed: Boolean

  """Used in User Articles filter, by tags or by time range, or both"""
  tagIds: [ID!]
  inRangeStart: DateTime
  inRangeEnd: DateTime
}

type UserInfo {
  """Timestamp of registration."""
  createdAt: DateTime

  """Is user name editable."""
  userNameEditable: Boolean!

  """User desciption."""
  description: String

  """
  the ipnsKey (`ipfs.io/ipns/<ipnsKey>/...`) for feed.json / rss.xml / index
  """
  ipnsKey: String

  """User email."""
  email: String

  """Weather user email is verified."""
  emailVerified: Boolean!

  """User connected social accounts."""
  socialAccounts: [SocialAccount!]!

  """User badges."""
  badges: [Badge!]

  """Timestamp of user agreement."""
  agreeOn: DateTime

  """Cover of profile page."""
  profileCover: String

  """Type of group."""
  group: UserGroup!

  """Login address"""
  ethAddress: String
  isWalletAuth: Boolean!

  """Connected wallet."""
  cryptoWallet: CryptoWallet

  """
  saved tags for showing on profile page, API allows up to 100, front-end lock'ed at lower limit
  """
  featuredTags: [Tag!]
}

type UserSettings {
  """User language setting."""
  language: UserLanguage!

  """User currency preference."""
  currency: QuoteCurrency!

  """Notification settings."""
  notification: NotificationSetting
}

type UserActivity {
  """User reading history."""
  history(input: ConnectionArgs!): ReadHistoryConnection!

  """User search history."""
  recentSearches(input: ConnectionArgs!): RecentSearchConnection!

  """Appreciations current user gave."""
  appreciationsSent(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user gave."""
  appreciationsSentTotal: Int!

  """Appreciations current user received."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user received."""
  appreciationsReceivedTotal: Int!
}

type UserAnalytics {
  """Top donators of current user."""
  topDonators(input: TopDonatorInput!): TopDonatorConnection!
}

input TopDonatorInput {
  after: String
  first: Int
  filter: TopDonatorFilter
}

input TopDonatorFilter {
  inRangeStart: DateTime
  inRangeEnd: DateTime
}

type TopDonatorConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopDonatorEdge!]
}

type TopDonatorEdge {
  cursor: String!
  node: User!
  donationCount: Int!
}

type UserStatus {
  """User state."""
  state: UserState!

  """User role and access level."""
  role: UserRole!

  """Number of articles published by user"""
  articleCount: Int!

  """Number of comments posted by user."""
  commentCount: Int!

  """Number of unread notices."""
  unreadNoticeCount: Int!

  """Whether there are unread activities from following."""
  unreadFollowing: Boolean!

  """Number of total written words."""
  totalWordCount: Int!

  """
  Number of referred user registration count (in Digital Nomad Campaign).
  """
  totalReferredCount: Int!

  """Weather login password is set for email login."""
  hasEmailLoginPassword: Boolean!

  """
  Number of chances for the user to change email in a nature day. Reset in UTC+8 0:00
  """
  changeEmailTimesLeft: Int!

  """Whether user already set payment password."""
  hasPaymentPassword: Boolean!

  """Number of articles donated by user"""
  donatedArticleCount: Int!

  """Number of times of donations received by user"""
  receivedDonationCount: Int!
}

type Liker {
  """Liker ID of LikeCoin"""
  likerId: String

  """Whether liker is a civic liker"""
  civicLiker: Boolean!

  """Total LIKE left in wallet."""
  total: Float!

  """Rate of LikeCoin/USD"""
  rateUSD: Float @deprecated(reason: "No longer in use")
}

type UserOSS {
  boost: Float!
  score: Float!
  restrictions: [UserRestriction!]!
}

type Appreciation {
  amount: Int!
  purpose: AppreciationPurpose!
  content: String!

  """Timestamp of appreciation."""
  createdAt: DateTime!

  """Recipient of appreciation."""
  recipient: User!

  """Sender of appreciation."""
  sender: User

  """Object that appreciation is meant for."""
  target: Article
}

type NotificationSetting {
  email: Boolean!
  mention: Boolean!
  userNewFollower: Boolean!
  articleNewComment: Boolean!
  articleNewAppreciation: Boolean!
  articleNewSubscription: Boolean!
  articleNewCollected: Boolean!
  articleCommentPinned: Boolean!

  """for circle owners"""
  circleNewSubscriber: Boolean!
  circleNewFollower: Boolean!
  circleNewUnsubscriber: Boolean!
  circleMemberNewBroadcastReply: Boolean!
  circleMemberNewDiscussion: Boolean!
  circleMemberNewDiscussionReply: Boolean!

  """for circle members & followers"""
  inCircleNewArticle: Boolean!
  inCircleNewBroadcast: Boolean!
  inCircleNewBroadcastReply: Boolean!
  inCircleNewDiscussion: Boolean!
  inCircleNewDiscussionReply: Boolean!
}

type ReadHistory {
  article: Article!
  readAt: DateTime!
}

type Badge {
  type: BadgeType!
}

type AuthResult {
  auth: Boolean!
  token: String
  type: AuthResultType!
  user: User
}

enum AuthResultType {
  Login
  Signup
  LinkAccount
}

type SigningMessageResult {
  nonce: String!
  purpose: SigningMessagePurpose!
  signingMessage: String!
  createdAt: DateTime!
  expiredAt: DateTime!
}

type UserConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [UserEdge!]
}

type UserEdge {
  cursor: String!
  node: User!
}

type ReadHistoryConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ReadHistoryEdge!]
}

type ReadHistoryEdge {
  cursor: String!
  node: ReadHistory!
}

type RecentSearchConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [RecentSearchEdge!]
}

type RecentSearchEdge {
  cursor: String!
  node: String!
}

type AppreciationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [AppreciationEdge!]
}

type AppreciationEdge {
  cursor: String!
  node: Appreciation!
}

type FollowingActivityConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [FollowingActivityEdge!]
}

type FollowingActivityEdge {
  cursor: String!
  node: FollowingActivity!
}

union FollowingActivity = UserPublishArticleActivity | UserAddArticleTagActivity | UserBroadcastCircleActivity | UserCreateCircleActivity | UserRecommendationActivity | ArticleRecommendationActivity | CircleRecommendationActivity

type UserPublishArticleActivity {
  actor: User!
  createdAt: DateTime!

  """Article published by actor"""
  node: Article!
}

type UserAddArticleTagActivity {
  actor: User!
  createdAt: DateTime!

  """Article added to tag"""
  node: Article!

  """Tag added by article"""
  target: Tag!
}

type UserBroadcastCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Comment broadcast by actor"""
  node: Comment!

  """Circle that comment belongs to"""
  target: Circle!
}

type UserCreateCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Circle created by actor"""
  node: Circle!
}

type UserRecommendationActivity {
  """The source type of recommendation"""
  source: UserRecommendationActivitySource

  """Recommended users"""
  nodes: [User!]
}

enum UserRecommendationActivitySource {
  UserFollowing
}

type ArticleRecommendationActivity {
  """The source type of recommendation"""
  source: ArticleRecommendationActivitySource

  """Recommended articles"""
  nodes: [Article!]
}

enum ArticleRecommendationActivitySource {
  UserDonation
  ReadArticlesTags
}

type CircleRecommendationActivity {
  """The source type of recommendation"""
  source: CircleRecommendationActivitySource

  """Recommended circles"""
  nodes: [Circle!]
}

enum CircleRecommendationActivitySource {
  UserSubscription
}

type Following {
  circles(input: ConnectionArgs!): CircleConnection!
  tags(input: ConnectionArgs!): TagConnection!
  users(input: ConnectionArgs!): UserConnection!
}

type CryptoWallet {
  id: ID!
  address: String!

  """ does this address own any Travelogger NFTs? this value is cached at most 1day, and refreshed at next `nfts` query 
  """
  hasNFTs: Boolean!

  """NFT assets owned by this wallet address"""
  nfts: [NFTAsset!]
}

""" NFT Asset """
type NFTAsset {
  id: ID!
  name: String!
  description: String
  imageUrl: String!
  imagePreviewUrl: String

  """imageOriginalUrl: String!"""
  contractAddress: String!
  collectionName: String!
}

input UserInput {
  userName: String

  """used for case insensitive username search """
  userNameCaseIgnore: Boolean = false
  ethAddress: String
}

input SendVerificationCodeInput {
  email: String!
  type: VerificationCodeType!
  token: String

  """
  Redirect URL embedded in the verification email,
  use code instead if not provided.
  """
  redirectUrl: String

  """email content language"""
  language: UserLanguage
}

input ConfirmVerificationCodeInput {
  email: String!
  type: VerificationCodeType!
  code: String!
}

input ResetPasswordInput {
  password: String!
  codeId: ID!
  type: ResetPasswordType
}

input ChangeEmailInput {
  oldEmail: String!
  oldEmailCodeId: ID!
  newEmail: String!
  newEmailCodeId: ID!
}

input VerifyEmailInput {
  email: String!
  code: String!
}

input SetCurrencyInput {
  currency: QuoteCurrency
}

input UserRegisterInput {
  email: String!
  userName: String
  displayName: String!
  password: String!
  description: String
  codeId: ID!
  referralCode: String
}

input UserLoginInput {
  email: String!
  password: String!
}

input GenerateSigningMessageInput {
  address: String!
  purpose: SigningMessagePurpose
}

input WalletLoginInput {
  ethAddress: String!

  """the message being sign'ed, including nonce"""
  signedMessage: String!

  """sign'ed by wallet"""
  signature: String!

  """nonce from generateSigningMessage"""
  nonce: String!

  """required for wallet register"""
  email: String @deprecated(reason: "No longer in use")

  """email verification code, required for wallet register"""
  codeId: ID @deprecated(reason: "No longer in use")

  """used in register"""
  language: UserLanguage
  referralCode: String
}

input ResetLikerIdInput {
  id: ID!
}

input ResetWalletInput {
  id: ID!
}

input UpdateNotificationSettingInput {
  type: NotificationSettingType!
  enabled: Boolean!
}

input UpdateUserInfoInput {
  displayName: String
  userName: String @deprecated(reason: "use 'setUserName' instead")
  avatar: ID
  description: String
  language: UserLanguage
  agreeOn: Boolean
  profileCover: ID
  paymentPassword: String
  paymentPointer: String
  referralCode: String
}

input UpdateUserStateInput {
  id: ID
  emails: [String!]
  state: UserState!
  banDays: Int
  password: String
}

input UpdateUserRoleInput {
  id: ID!
  role: UserRole!
}

input UpdateUserExtraInput {
  id: ID!
  referralCode: String
}

input RefreshIPNSFeedInput {
  userName: String!

  """refresh how many recent articles, default to 50"""
  numArticles: Int = 50
}

input ToggleUsersBadgeInput {
  ids: [ID!]
  type: BadgeType!
  enabled: Boolean!
}

input UnbindLikerIdInput {
  id: ID!
  likerId: String!
}

input ClearReadHistoryInput {
  id: ID
}

input MigrationInput {
  type: MigrationType
  files: [Upload]!
}

input ClaimLogbooksInput {
  ethAddress: String!

  """the message being sign'ed, including nonce"""
  signedMessage: String!

  """sign'ed by wallet"""
  signature: String!

  """nonce from generateSigningMessage"""
  nonce: String!
}

input FeaturedTagsInput {
  """ tagIds """
  ids: [ID!]!
}

type ClaimLogbooksResult {
  ids: [ID!]
  txHash: String!
}

enum BadgeType {
  seed
  golden_motor
  architect
  nomad1
  nomad2
  nomad3
  nomad4
}

enum VerificationCodeType {
  register
  email_verify
  email_otp
  email_reset @deprecated(reason: "No longer in use")
  email_reset_confirm @deprecated(reason: "No longer in use")
  password_reset @deprecated(reason: "No longer in use")
  payment_password_reset
}

enum ResetPasswordType {
  account
  payment
}

enum UserInfoFields {
  displayName
  avatar
  description
  email
  agreeOn
}

enum UserLanguage {
  en
  zh_hans
  zh_hant
}

enum NotificationSettingType {
  email
  mention
  userNewFollower
  articleNewComment
  articleNewAppreciation
  articleNewSubscription
  articleNewCollected
  articleCommentPinned

  """for circle owners"""
  circleNewSubscriber
  circleNewFollower
  circleNewUnsubscriber
  circleNewDiscussion
  circleMemberBroadcast
  circleMemberNewDiscussion
  circleMemberNewDiscussionReply
  circleMemberNewBroadcastReply

  """for circle members"""
  inCircleNewArticle
  inCircleNewBroadcast
  inCircleNewBroadcastReply
  inCircleNewDiscussion
  inCircleNewDiscussionReply
}

enum UserState {
  active
  banned
  archived
  frozen
}

enum UserRole {
  user
  admin
}

enum UserGroup {
  a
  b
}

enum AppreciationPurpose {
  appreciate
  appreciateComment
  appreciateSubsidy
  invitationAccepted
  joinByInvitation
  joinByTask
  firstPost
  systemSubsidy
}

enum MigrationType {
  medium
}

enum AuthorsType {
  active
  appreciated
  default
  trendy
}

enum CryptoWalletSignaturePurpose {
  airdrop
  connect
  signup
  login
}

enum SigningMessagePurpose {
  airdrop
  connect
  signup
  login
  claimLogbook
}

enum QuoteCurrency {
  TWD
  HKD
  USD
}

type SocialAccount {
  type: SocialAccountType!
  userName: String
  email: String
}

enum SocialAccountType {
  Google
  Twitter
  Facebook
}

input EmailLoginInput {
  email: String!
  passwordOrCode: String!

  """used in register"""
  language: UserLanguage
  referralCode: String
}

input SocialLoginInput {
  type: SocialAccountType!
  authorizationCode: String

  """OAuth2 PKCE code_verifier for Facebook and Twitter"""
  codeVerifier: String

  """OIDC nonce for Google"""
  nonce: String

  """oauth token/verifier in OAuth1.0a for Twitter"""
  oauth1Credential: Oauth1CredentialInput

  """used in register"""
  language: UserLanguage
  referralCode: String
}

input Oauth1CredentialInput {
  oauthToken: String!
  oauthVerifier: String!
}

input SetUserNameInput {
  userName: String!
}

input SetEmailInput {
  email: String!
}

input SetPasswordInput {
  password: String!
}

input RemoveSocialLoginInput {
  type: SocialAccountType!
}

input UserArticlesInput {
  after: String
  first: Int
  sort: UserArticlesSort = newest
  filter: UserArticlesFilter
}

enum UserArticlesSort {
  newest
  mostReaders
  mostAppreciations
  mostComments
  mostDonations
}

input UserArticlesFilter {
  state: ArticleState = active
}

union Response = Article | Comment

type ResponseConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ResponseEdge!]
}

type ResponseEdge {
  cursor: String!
  node: Response!
}

input ResponsesInput {
  sort: ResponseSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: Int
  articleOnly: Boolean
}

"""Enums for sorting responses."""
enum ResponseSort {
  oldest
  newest
}

input ExchangeRatesInput {
  from: TransactionCurrency
  to: QuoteCurrency
}

type ExchangeRate {
  from: TransactionCurrency!
  to: QuoteCurrency!
  rate: Float!

  """Last updated time from currency convertor APIs"""
  updatedAt: DateTime!
}

union TransactionTarget = Article | Circle | Transaction

type Wallet {
  balance: Balance!
  transactions(input: TransactionsArgs!): TransactionConnection!

  """Account of Stripe Connect to manage payout"""
  stripeAccount: StripeAccount

  """
  URL of Stripe Dashboard to manage subscription invoice and payment method
  """
  customerPortal: String

  """The last four digits of the card."""
  cardLast4: String
}

type Balance {
  HKD: Float!
}

type Transaction {
  id: ID!
  state: TransactionState!
  purpose: TransactionPurpose!
  amount: Float!
  fee: Float!
  currency: TransactionCurrency!

  """Timestamp of transaction."""
  createdAt: DateTime!

  """Recipient of transaction."""
  recipient: User

  """Sender of transaction."""
  sender: User

  """Related target article or transaction."""
  target: TransactionTarget

  """Message for end user, including reason of failure."""
  message: String

  """blockchain transaction info of ERC20/native token payment transaction"""
  blockchainTx: BlockchainTransaction
}

type TransactionConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TransactionEdge!]
}

type TransactionEdge {
  cursor: String!
  node: Transaction!
}

input TransactionsArgs {
  after: String
  first: Int

  """deprecated, use TransactionsFilter.id instead."""
  id: ID

  """deprecated, use TransactionsFilter.states instead."""
  states: [TransactionState!]
  filter: TransactionsFilter
}

input TransactionsFilter {
  id: ID
  states: [TransactionState!]
  currency: TransactionCurrency
  purpose: TransactionPurpose
}

enum TransactionState {
  pending
  succeeded
  failed
  canceled
}

enum TransactionPurpose {
  donation
  addCredit
  refund
  payout
  subscriptionSplit
  dispute
  payoutReversal
}

enum TransactionCurrency {
  HKD
  LIKE
  USDT
}

type AddCreditResult {
  transaction: Transaction!

  """The client secret of this PaymentIntent."""
  client_secret: String!
}

type PayToResult {
  transaction: Transaction!

  """Only available when paying with LIKE."""
  redirectUrl: String
}

input AddCreditInput {
  amount: Float!
}

input PayToInput {
  amount: Float!
  currency: TransactionCurrency!
  purpose: TransactionPurpose!
  recipientId: ID!
  targetId: ID

  """for HKD payment"""
  password: String

  """for ERC20/native token payment"""
  chain: Chain
  txHash: String
}

input PayoutInput {
  amount: Float!
  password: String!
}

input ConnectStripeAccountInput {
  country: StripeAccountCountry!
}

type StripeAccount {
  id: ID!
  loginUrl: String!
}

type ConnectStripeAccountResult {
  redirectUrl: String!
}

enum StripeAccountCountry {
  Australia
  Austria
  Belgium
  Bulgaria
  Canada
  Cyprus
  Denmark
  Estonia
  Finland
  France
  Germany
  Greece
  HongKong
  Ireland
  Italy
  Latvia
  Lithuania
  Luxembourg
  Malta
  Netherlands
  NewZealand
  Norway
  Poland
  Portugal
  Romania
  Singapore
  Slovakia
  Slovenia
  Spain
  Sweden
  UnitedKingdom
  UnitedStates
}

enum Chain {
  Polygon
  Optimism
}

type BlockchainTransaction {
  chain: Chain!
  txHash: String!
}

type OAuthClient {
  """Unique Client ID of this OAuth Client."""
  id: ID!

  """App name"""
  name: String!

  """App Description"""
  description: String

  """URL for oauth client's official website"""
  website: String

  """Scopes"""
  scope: [String!]

  """URL for oauth client's avatar."""
  avatar: String

  """Client secret"""
  secret: String!

  """Redirect URIs"""
  redirectURIs: [String!]

  """Grant Types"""
  grantTypes: [GrantType!]

  """Linked Developer Account"""
  user: User

  """Creation Date"""
  createdAt: DateTime!
}

type OAuthClientConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [OAuthClientEdge!]
}

type OAuthClientEdge {
  cursor: String!
  node: OAuthClient!
}

input OAuthClientInput {
  id: ID!
}

input PutOAuthClientInput {
  id: ID
  name: String
  description: String
  website: String
  scope: [String!]
  avatar: ID
  secret: String
  redirectURIs: [String!]
  grantTypes: [GrantType!]
  user: ID
}

enum GrantType {
  authorization_code
  refresh_token
}

type Collection implements Node & PinnableWork {
  id: ID!
  title: String!
  cover: String
  description: String
  author: User!
  articles(input: CollectionArticlesInput!): ArticleConnection!
  pinned: Boolean!
  updatedAt: DateTime!

  """Check if the collection contains the article"""
  contains(input: NodeInput!): Boolean!
}

type CollectionEdge {
  cursor: String!
  node: Collection!
}

type CollectionConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CollectionEdge!]
}

input CollectionArticlesInput {
  after: String
  first: Int
  reversed: Boolean
}

input PutCollectionInput {
  id: ID
  title: String
  cover: ID
  description: String
  pinned: Boolean
}

input DeleteCollectionsInput {
  ids: [ID!]!
}

input AddCollectionsArticlesInput {
  collections: [ID!]!
  articles: [ID!]!
}

input DeleteCollectionArticlesInput {
  collection: ID!
  articles: [ID!]!
}

input ReorderMoveInput {
  item: ID!

  """
  The new position move to. To move item to the beginning of the list, set to 0. To the end of the list, set to the length of the list - 1.
  """
  newPosition: Int!
}

input ReorderCollectionArticlesInput {
  collection: ID!
  moves: [ReorderMoveInput!]!
}