directive @constraint(
  """String constraints"""
  minLength: Int
  maxLength: Int
  startsWith: String
  endsWith: String
  contains: String
  notContains: String
  pattern: String
  format: String

  """Number constraints"""
  min: Int
  max: Int
  exclusiveMin: Int
  exclusiveMax: Int
  multipleOf: Int
  uniqueTypeName: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

directive @cacheControl(maxAge: Int, scope: CacheControlScope, inheritMaxAge: Boolean) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

directive @cost(multipliers: [String], useMultipliers: Boolean, complexity: CostComplexity) on OBJECT | FIELD_DEFINITION

"""Rate limit within a given period of time, in seconds"""
directive @rateLimit(period: Int!, limit: Int!) on FIELD_DEFINITION

directive @auth(mode: String!, group: String) on FIELD_DEFINITION

directive @privateCache(strict: Boolean! = false) on FIELD_DEFINITION

directive @objectCache(maxAge: Int = 1000) on OBJECT | FIELD_DEFINITION

directive @logCache(type: String!) on FIELD_DEFINITION

directive @purgeCache(type: String!) on FIELD_DEFINITION

type Query {
  article(input: ArticleInput!): Article
  circle(input: CircleInput!): Circle
  node(input: NodeInput!): Node
  nodes(input: NodesInput!): [Node!]
  frequentSearch(input: FrequentSearchInput!): [String!]
  search(input: SearchInput!): SearchResultConnection!
  official: Official!
  oss: OSS!
  viewer: User
  user(input: UserInput!): User
  oauthClient(input: OAuthClientInput!): OAuthClient
}

type Mutation {
  """Publish an article onto IPFS."""
  publishArticle(input: PublishArticleInput!): Draft!

  """Edit an article."""
  editArticle(input: EditArticleInput!): Article!

  """Subscribe or Unsubscribe article"""
  toggleSubscribeArticle(input: ToggleItemInput!): Article!

  """Appreciate an article."""
  appreciateArticle(input: AppreciateArticleInput!): Article!

  """Read an article."""
  readArticle(input: ReadArticleInput!): Article!

  """
  Create a Topic when no id is given, update fields when id is given. Throw error if no id & no title.
  """
  putTopic(input: PutTopicInput!): Topic!

  """
  Create a Chapter when no id is given, update fields when id is given. Throw error if no id & no title, or no id & no topic.
  """
  putChapter(input: PutChapterInput!): Chapter!

  """Delete topics"""
  deleteTopics(input: DeleteTopicsInput!): Boolean!

  """Sort topics"""
  sortTopics(input: SortTopicsInput!): [Topic!]!

  """Follow or unfollow tag."""
  toggleFollowTag(input: ToggleItemInput!): Tag!

  """Create or update tag."""
  putTag(input: PutTagInput!): Tag!

  """Update member, permission and othters of a tag."""
  updateTagSetting(input: UpdateTagSettingInput!): Tag!

  """Add one tag to articles."""
  addArticlesTags(input: AddArticlesTagsInput!): Tag!

  """Update articles' tag."""
  updateArticlesTags(input: UpdateArticlesTagsInput!): Tag!

  """Delete one tag from articles"""
  deleteArticlesTags(input: DeleteArticlesTagsInput!): Tag!

  """
  #############
       OSS    #
  #############
  """
  toggleArticleRecommend(input: ToggleRecommendInput!): Article!
  updateArticleState(input: UpdateArticleStateInput!): Article!
  toggleTagRecommend(input: ToggleRecommendInput!): Tag!
  deleteTags(input: DeleteTagsInput!): Boolean
  renameTag(input: RenameTagInput!): Tag!
  mergeTags(input: MergeTagsInput!): Tag!

  """Create or update a Circle."""
  putCircle(input: PutCircleInput!): Circle!

  """Follow or unfollow a Circle."""
  toggleFollowCircle(input: ToggleItemInput!): Circle! @deprecated(reason: "No longer in use")

  """Subscribe a Circle."""
  subscribeCircle(input: SubscribeCircleInput!): SubscribeCircleResult!

  """Unsubscribe a Circle."""
  unsubscribeCircle(input: UnsubscribeCircleInput!): Circle!

  """Add or remove Circle's articles"""
  putCircleArticles(input: PutCircleArticlesInput!): Circle! @deprecated(reason: "No longer in use")

  """Invite others to join circle"""
  invite(input: InviteCircleInput!): [Invitation!]

  """Publish or update a comment."""
  putComment(input: PutCommentInput!): Comment!

  """Remove a comment."""
  deleteComment(input: DeleteCommentInput!): Comment!

  """Pin or Unpin a comment."""
  togglePinComment(input: ToggleItemInput!): Comment!

  """Upvote or downvote a comment."""
  voteComment(input: VoteCommentInput!): Comment!

  """Unvote a comment."""
  unvoteComment(input: UnvoteCommentInput!): Comment!

  """Update a comments' state."""
  updateCommentsState(input: UpdateCommentsStateInput!): [Comment!]!

  """Pin a comment."""
  pinComment(input: PinCommentInput!): Comment!

  """Unpin a comment."""
  unpinComment(input: UnpinCommentInput!): Comment!

  """Create or update a draft."""
  putDraft(input: PutDraftInput!): Draft!

  """Remove a draft."""
  deleteDraft(input: DeleteDraftInput!): Boolean

  """Mark all received notices as read."""
  markAllNoticesAsRead: Boolean

  """Upload a single file."""
  singleFileUpload(input: SingleFileUploadInput!): Asset!

  """Add specific user behavior record."""
  logRecord(input: LogRecordInput!): Boolean

  """
  #############
       OSS    #
  #############
  """
  setBoost(input: SetBoostInput!): Node!
  putRemark(input: PutRemarkInput!): String
  putSkippedListItem(input: PutSkippedListItemInput!): [SkippedListItem!]
  setFeature(input: SetFeatureInput!): Feature!
  toggleSeedingUsers(input: ToggleSeedingUsersInput!): [User]!
  putAnnouncement(input: PutAnnouncementInput!): Announcement!
  deleteAnnouncements(input: DeleteAnnouncementsInput!): Boolean

  """Send verification code for email."""
  sendVerificationCode(input: SendVerificationCodeInput!): Boolean

  """Confirm verification code from email."""
  confirmVerificationCode(input: ConfirmVerificationCodeInput!): ID!

  """Reset user or payment password."""
  resetPassword(input: ResetPasswordInput!): Boolean

  """Change user email."""
  changeEmail(input: ChangeEmailInput!): User!

  """Register user, can only be used on matters.news website."""
  userRegister(input: UserRegisterInput!): AuthResult!

  """Login user."""
  userLogin(input: UserLoginInput!): AuthResult!

  """Logout user."""
  userLogout: Boolean!

  """Generate or claim a Liker ID through LikeCoin"""
  generateLikerId: User!

  """Reset Liker ID"""
  resetLikerId(input: ResetLikerIdInput!): User!

  """Update user information."""
  updateUserInfo(input: UpdateUserInfoInput!): User!

  """Update user notification settings."""
  updateNotificationSetting(input: UpdateNotificationSettingInput!): User!

  """Follow or Unfollow current user."""
  toggleFollowUser(input: ToggleItemInput!): User!

  """Block or Unblock a given user."""
  toggleBlockUser(input: ToggleItemInput!): User!

  """Subscribe/ Unsubscribe Push Notification."""
  toggleSubscribePush(input: ToggleItemInput!): User!

  """Clear read history for user."""
  clearReadHistory(input: ClearReadHistoryInput!): Boolean

  """Clear search history for user."""
  clearSearchHistory: Boolean

  """Migrate articles from other service provider."""
  migration(input: MigrationInput!): Boolean

  """Update wallet."""
  putWallet(input: PutWalletInput!): CryptoWallet!

  """Delete connected wallet."""
  deleteWallet(input: DeleteWalletInput!): Boolean!

  """Update state of a user, used in OSS."""
  updateUserState(input: UpdateUserStateInput!): [User!]

  """Update state of a user, used in OSS."""
  updateUserRole(input: UpdateUserRoleInput!): User!
  toggleUsersBadge(input: ToggleUsersBadgeInput!): [User]!

  """Add Credit to User Wallet"""
  addCredit(input: AddCreditInput!): AddCreditResult!

  """Pay to another user or article"""
  payTo(input: PayToInput!): PayToResult!

  """Payout to user"""
  payout(input: PayoutInput!): Transaction!

  """Create Stripe Connect account for Payout"""
  connectStripeAccount(input: ConnectStripeAccountInput!): ConnectStripeAccountResult!

  """Create or Update an OAuth Client, used in OSS."""
  putOAuthClient(input: PutOAuthClientInput!): OAuthClient
}

"""
This type contains metadata, content, hash and related data of an article. If you
want information about article's comments. Please check Comment type.
"""
type Article implements Node {
  """Unique ID of this article"""
  id: ID!

  """The number represents how popular is this article."""
  topicScore: Int

  """Slugified article title."""
  slug: String!

  """Time of this article was created."""
  createdAt: DateTime!

  """Time of this article was revised."""
  revisedAt: DateTime

  """State of this article."""
  state: ArticleState!

  """Author of this article."""
  author: User!

  """Article title."""
  title: String!

  """Article cover's link."""
  cover: String

  """
  List of assets are belonged to this article (Only the author can access currently).
  """
  assets: [Asset!]!

  """A short summary for this article."""
  summary: String!

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Tags attached to this article."""
  tags: [Tag!]

  """Word count of this article."""
  wordCount: Int

  """IPFS hash of this article."""
  dataHash: String!

  """Media hash, composed of cid encoding, of this article."""
  mediaHash: String!

  """Content of this article."""
  content: String!

  """Original language of content"""
  language: String

  """List of articles which added this article into their collections."""
  collectedBy(input: ConnectionArgs!): ArticleConnection!

  """List of articles added into this article' collection."""
  collection(input: ConnectionArgs!): ArticleConnection!

  """Related articles to this article."""
  relatedArticles(input: ConnectionArgs!): ArticleConnection!

  """Donation-related articles to this article."""
  relatedDonationArticles(input: RelatedDonationArticlesInput!): ArticleConnection!

  """Appreciations history of this article."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciations recieved of this article."""
  appreciationsReceivedTotal: Int!

  """Subscribers of this article."""
  subscribers(input: ConnectionArgs!): UserConnection!

  """Limit the nuhmber of appreciate per user."""
  appreciateLimit: Int!

  """Number represents how many times per user can appreciate this article."""
  appreciateLeft: Int!

  """This value determines if current viewer has appreciated or not."""
  hasAppreciate: Boolean!

  """This value determines if current viewer can SuperLike or not."""
  canSuperLike: Boolean!

  """This value determines if current Viewer has subscribed of not."""
  subscribed: Boolean!

  """
  This value determines if this article is an author selected article or not.
  """
  sticky: Boolean!

  """Translation of article title and content."""
  translation(input: TranslationArgs): ArticleTranslation

  """Transactions history of this article."""
  transactionsReceivedBy(input: TransactionsReceivedByArgs!): UserConnection!

  """Cumulative reading time in seconds"""
  readTime: Float!

  """Drafts linked to this article."""
  drafts: [Draft!]

  """Revision Count"""
  revisionCount: Int!

  """Access related fields on circle"""
  access: ArticleAccess!

  """License Type"""
  license: ArticleLicenseType!

  """
  #############
       OSS    #
  #############
  """
  oss: ArticleOSS!
  remark: String

  """The counting number of comments."""
  commentCount: Int!

  """The number determines how many pinned comments can be set."""
  pinCommentLimit: Int!

  """The number determines how many comments can be set as pinned comment."""
  pinCommentLeft: Int!

  """List of pinned comments."""
  pinnedComments: [Comment!]

  """List of featured comments of this article."""
  featuredComments(input: FeaturedCommentsInput!): CommentConnection!

  """List of comments of this article."""
  comments(input: CommentsInput!): CommentConnection!

  """The counting number of this article."""
  responseCount: Int!

  """List of responses of a article."""
  responses(input: ResponsesInput!): ResponseConnection!
}

"""
This type contains metadata, content and related data of Chapter type, which is a container for Article type. A Chapter belong to a Topic.
"""
type Chapter implements Node {
  """Unique id of this chapter."""
  id: ID!

  """Title of this chapter."""
  title: String!

  """Description of this chapter."""
  description: String

  """Number articles included in this chapter."""
  articleCount: Int!

  """Articles included in this Chapter"""
  articles: [Article!]

  """The topic that this Chapter belongs to."""
  topic: Topic!
}

"""
This type contains metadata, content and related data of a topic, which is a container for Article and Chapter types.
"""
type Topic implements Node {
  """Unique id of this topic."""
  id: ID!

  """Title of this topic."""
  title: String!

  """Cover of this topic."""
  cover: String

  """Description of this topic."""
  description: String

  """Number of chapters included in this topic."""
  chapterCount: Int!

  """Number articles included in this topic."""
  articleCount: Int!

  """List of chapters included in this topic."""
  chapters: [Chapter!]

  """List of articles included in this topic."""
  articles: [Article!]

  """Author of this topic."""
  author: User!

  """Whether this topic is public or not."""
  public: Boolean!

  """Latest published article on this topic"""
  latestArticle: Article
}

"""This type contains content, count and related data of an article tag."""
type Tag implements Node {
  """Unique id of this tag."""
  id: ID!

  """Content of this tag."""
  content: String!

  """List of how many articles were attached with this tag."""
  articles(input: TagArticlesInput!): ArticleConnection!

  """This value determines if this article is selected by this tag or not."""
  selected(input: TagSelectedInput!): Boolean!

  """Time of this tag was created."""
  createdAt: DateTime!

  """Tag's cover link."""
  cover: String

  """Description of this tag."""
  description: String

  """Editors of this tag."""
  editors(input: TagEditorsInput): [User!]

  """Creator of this tag."""
  creator: User

  """Owner of this tag."""
  owner: User

  """This value determines if current viewer is following or not."""
  isFollower: Boolean

  """Followers of this tag."""
  followers(input: ConnectionArgs!): UserConnection!

  """Participants of this tag."""
  participants(input: ConnectionArgs!): UserConnection!

  """This value determines if it is official."""
  isOfficial: Boolean

  """
  #############
       OSS    #
  #############
  """
  oss: TagOSS!
  remark: String
  deleted: Boolean!
}

type ArticleAccess {
  type: ArticleAccessType!
  secret: String
  circle: Circle
}

type ArticleOSS {
  boost: Float!
  score: Float!
  inRecommendIcymi: Boolean!
  inRecommendHottest: Boolean!
  inRecommendNewest: Boolean!
}

type ArticleTranslation {
  title: String
  content: String
  summary: String
}

type TagOSS {
  boost: Float!
  score: Float!
  selected: Boolean!
}

type ArticleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleEdge!]
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

type TopicConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopicEdge!]
}

type TopicEdge {
  cursor: String!
  node: Topic!
}

type TagConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TagEdge!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

input ArticleInput {
  mediaHash: String!
}

input PublishArticleInput {
  id: ID!
}

input EditArticleInput {
  id: ID!
  state: ArticleState
  sticky: Boolean
  summary: String
  tags: [String!]
  content: String
  cover: ID
  collection: [ID!]
  circle: ID
  accessType: ArticleAccessType

  """License Type, `ARR` is only for paywalled article"""
  license: ArticleLicenseType
}

input AppreciateArticleInput {
  id: ID!
  amount: Int!
  token: String
  superLike: Boolean
}

input ReadArticleInput {
  id: ID!
}

input PutTopicInput {
  id: ID
  title: String
  description: String
  cover: ID
  public: Boolean
  articles: [ID!]
  chapters: [ID!]
}

input PutChapterInput {
  id: ID
  title: String
  description: String
  topic: ID
  articles: [ID!]
}

input DeleteTopicsInput {
  ids: [ID!]!
}

input SortTopicsInput {
  ids: [ID!]!
}

input ToggleRecommendInput {
  id: ID!
  enabled: Boolean!
  type: RecommendTypes
}

input UpdateArticleStateInput {
  id: ID!
  state: ArticleState!
}

input DeleteTagsInput {
  ids: [ID!]!
}

input RenameTagInput {
  id: ID!
  content: String!
}

input MergeTagsInput {
  ids: [ID!]!
  content: String!
}

input PutTagInput {
  id: ID
  content: String
  cover: ID
  description: String
}

input UpdateTagSettingInput {
  id: ID!
  type: UpdateTagSettingType!
  editors: [ID!]
}

input AddArticlesTagsInput {
  id: ID!
  articles: [ID!]
  selected: Boolean
}

input UpdateArticlesTagsInput {
  id: ID!
  articles: [ID!]
  isSelected: Boolean!
}

input DeleteArticlesTagsInput {
  id: ID!
  articles: [ID!]
}

input TagArticlesInput {
  after: String
  first: Int
  oss: Boolean
  selected: Boolean
}

input TagSelectedInput {
  id: ID
  mediaHash: String
}

input TagEditorsInput {
  excludeAdmin: Boolean
  excludeOwner: Boolean
}

input TransactionsReceivedByArgs {
  after: String
  first: Int
  purpose: TransactionPurpose!
}

input TranslationArgs {
  language: UserLanguage!
}

input RelatedDonationArticlesInput {
  after: String
  first: Int
  oss: Boolean

  """index of article list, min: 0, max: 49"""
  random: Int
}

"""Enums for an article state."""
enum ArticleState {
  active
  archived
  banned
}

"""Enums for types of article access"""
enum ArticleAccessType {
  public
  paywall
}

"""Enums for types of article license"""
enum ArticleLicenseType {
  cc_0
  cc_by_nc_nd_2
  arr
}

"""Enums for types of recommend articles."""
enum RecommendTypes {
  icymi
  hottest
  newest
}

enum UpdateTagSettingType {
  adopt
  leave
  add_editor
  remove_editor
  leave_editor
}

type Circle implements Node {
  """Unique ID."""
  id: ID!

  """Circle avatar's link."""
  avatar: String @deprecated(reason: "No longer in use")

  """Circle cover's link."""
  cover: String @deprecated(reason: "No longer in use")

  """Slugified name of this Circle."""
  name: String! @deprecated(reason: "No longer in use")

  """Human readable name of this Circle."""
  displayName: String! @deprecated(reason: "No longer in use")

  """A short description of this Circle."""
  description: String

  """Prices offered by this Circle."""
  prices: [Price!]

  """Circle owner."""
  owner: User!

  """List of Circle member."""
  members(input: ConnectionArgs!): MemberConnection! @deprecated(reason: "No longer in use")

  """List of Circle follower."""
  followers(input: ConnectionArgs!): UserConnection! @deprecated(reason: "No longer in use")

  """List of works belong to this Circle."""
  works(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "No longer in use")

  """State of this Circle."""
  state: CircleState! @deprecated(reason: "No longer in use")

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is following Circle or not."""
  isFollower: Boolean! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is Member or not."""
  isMember: Boolean! @deprecated(reason: "No longer in use")

  """Invitations belonged to this Circle."""
  invites: Invites!

  """Invitation used by current viewer."""
  invitedBy: Invitation

  """Analytics dashboard."""
  analytics: CircleAnalytics!

  """Comments broadcasted by Circle owner."""
  broadcast(input: ConnectionArgs!): CommentConnection!

  """Pinned comments broadcasted by Circle owner."""
  pinnedBroadcast: [Comment!]

  """Comments made by Circle member."""
  discussion(input: ConnectionArgs!): CommentConnection!

  """Discussion (exclude replies) count of this circle."""
  discussionThreadCount: Int!

  """Discussion (include replies) count of this circle."""
  discussionCount: Int!
}

type Member {
  """User who join to a Circle."""
  user: User!

  """Price chosen by user when joining a Circle."""
  price: Price!
}

type Price {
  """Unique ID."""
  id: ID!

  """Amount of Price."""
  amount: Float!

  """Current Price belongs to whcih Circle."""
  circle: Circle!

  """Currency of Price."""
  currency: TransactionCurrency!

  """State of Price."""
  state: PriceState!

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")
}

type CircleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CircleEdge!]
}

type CircleEdge {
  cursor: String!
  node: Circle!
}

type MemberConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [MemberEdge!]
}

type MemberEdge {
  cursor: String!
  node: Member!
}

type SubscribeCircleResult {
  circle: Circle!

  """client secret for SetupIntent."""
  client_secret: String
}

type Invites {
  """Accepted invitation list"""
  accepted(input: ConnectionArgs!): InvitationConnection!

  """Pending invitation list"""
  pending(input: ConnectionArgs!): InvitationConnection!
}

type Invitation {
  """Unique ID."""
  id: ID!

  """Target person of this invitation."""
  invitee: Invitee!

  """Creator of this invitation."""
  inviter: User!

  """Invitation of current Circle."""
  circle: Circle!

  """Free period of this invitation."""
  freePeriod: Int!

  """Created time."""
  createdAt: DateTime!

  """Sent time."""
  sentAt: DateTime!

  """Accepted time."""
  acceptedAt: DateTime

  """Determine it's specific state."""
  state: InvitationState!
}

type Person {
  email: String!
}

union Invitee = Person | User

type InvitationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [InvitationEdge!]
}

type InvitationEdge {
  cursor: String!
  node: Invitation!
}

type CircleAnalytics {
  income: CircleIncomeAnalytics!
  subscriber: CircleSubscriberAnalytics!
  follower: CircleFollowerAnalytics!
  content: CircleContentAnalytics!
}

type CircleIncomeAnalytics {
  """income history of last 4 months"""
  history: [MonthlyDatum!]!

  """total income of all time"""
  total: Float!

  """income of this month"""
  thisMonth: Float!

  """income of next month"""
  nextMonth: Float!
}

type CircleSubscriberAnalytics {
  """subscriber count history of last 4 months"""
  subscriberHistory: [MonthlyDatum!]!

  """invitee count history of last 4 months"""
  inviteeHistory: [MonthlyDatum!]!

  """current subscriber count"""
  currentSubscriber: Int!

  """current invitee count"""
  currentInvitee: Int!
}

type CircleFollowerAnalytics {
  """subscriber count history of last 4 months"""
  history: [MonthlyDatum!]!

  """current follower count"""
  current: Int!

  """the percentage of follower count in reader count of circle articles"""
  followerPercentage: Float!
}

type CircleContentAnalytics {
  public: [CircleContentAnalyticsDatum!]
  paywall: [CircleContentAnalyticsDatum!]
}

type CircleContentAnalyticsDatum {
  node: Article!
  readCount: Int!
}

type MonthlyDatum {
  value: Float!
  date: DateTime!
}

input CircleInput {
  """Slugified name of a Circle."""
  name: String!
}

input PutCircleInput {
  """Unique ID."""
  id: ID

  """Unique ID of a Circle's avatar."""
  avatar: ID

  """Unique ID of a Circle's cover."""
  cover: ID

  """Slugified name of a Circle."""
  name: String

  """Human readable name of this Circle."""
  displayName: String

  """A short description of this Circle."""
  description: String

  """Circle's subscription fee."""
  amount: Float
}

input ToggleCircleMemberInput {
  """Unique ID."""
  id: ID!

  """Toggle value."""
  enabled: Boolean!

  """Unique ID of target user."""
  targetId: ID!
}

input SubscribeCircleInput {
  """Unique ID."""
  id: ID!

  """Wallet password."""
  password: String
}

input UnsubscribeCircleInput {
  """Unique ID."""
  id: ID!
}

input PutCircleArticlesInput {
  """Circle ID"""
  id: ID!

  """Article Ids"""
  articles: [ID!]

  """Action Type"""
  type: PutCircleArticlesType!

  """Access Type, `public` or `paywall` only."""
  accessType: ArticleAccessType!

  """License Type, `ARR` is only for paywalled article"""
  license: ArticleLicenseType
}

input InviteCircleInput {
  invitees: [InviteCircleInvitee!]!
  freePeriod: Int!
  circleId: ID!
}

input InviteCircleInvitee {
  id: ID
  email: String
}

enum CircleState {
  active
  archived
}

enum PriceState {
  active
  archived
}

enum PutCircleArticlesType {
  add
  remove
}

enum InvitationState {
  accepted
  pending
  transfer_succeeded
  transfer_failed
}

"""
This type contains content, author, descendant comments and related data of a comment.
"""
type Comment implements Node {
  """Unique ID of this comment."""
  id: ID!

  """State of this comment."""
  state: CommentState!

  """Time of this comment was created."""
  createdAt: DateTime!

  """Content of this comment."""
  content: String

  """Author of this comment."""
  author: User!

  """This value determines this comment is pinned or not."""
  pinned: Boolean!

  """This value determines this comment is from article donator or not."""
  fromDonator: Boolean!

  """The counting number of upvotes."""
  upvotes: Int!

  """The counting number of downvotes."""
  downvotes: Int!

  """The value determines current user's vote."""
  myVote: Vote

  """Descendant comments of this comment."""
  comments(input: CommentCommentsInput!): CommentConnection!

  """Parent comment of this comment."""
  parentComment: Comment

  """A Comment that this comment replied to."""
  replyTo: Comment
  remark: String

  """Current comment belongs to which Node."""
  node: Node!
}

type CommentConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CommentEdge!]
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input PutCommentInput {
  comment: CommentInput!

  """edit comment if id is provided"""
  id: ID
}

input CommentInput {
  content: String!
  replyTo: ID
  parentId: ID
  mentions: [ID!]
  type: CommentType!

  """one of the following ids is required"""
  articleId: ID
  circleId: ID
}

input CommentCommentsInput {
  author: ID
  sort: CommentSort
  after: String
  first: Int
}

input CommentsInput {
  sort: CommentSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: Int
  filter: CommentsFilter
}

input FeaturedCommentsInput {
  sort: CommentSort
  after: String
  first: Int
}

input CommentsFilter {
  parentComment: ID
  state: CommentState
  author: ID
}

"""Enums for sorting comments by time."""
enum CommentSort {
  oldest
  newest
}

input PinCommentInput {
  id: ID!
}

input UnpinCommentInput {
  id: ID!
}

input DeleteCommentInput {
  id: ID!
}

input VoteCommentInput {
  vote: Vote!
  id: ID!
}

input UnvoteCommentInput {
  id: ID!
}

input UpdateCommentsStateInput {
  ids: [ID!]!
  state: CommentState!
}

"""Enums for vote types."""
enum Vote {
  up
  down
}

"""Enums for comment state."""
enum CommentState {
  active
  archived
  banned
  collapsed
}

enum CommentType {
  article
  circleDiscussion
  circleBroadcast
}

"""
This type contains content, collections, assets and related data of a draft.
"""
type Draft implements Node {
  """Unique ID of this draft."""
  id: ID!

  """Media hash, composed of cid encoding, of this draft."""
  mediaHash: String

  """Draft title."""
  title: String

  """Slugified draft title."""
  slug: String!

  """Summary of this draft."""
  summary: String

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Content of this draft."""
  content: String

  """Time of this draft was created."""
  createdAt: DateTime!

  """Last time of this draft was upadted."""
  updatedAt: DateTime!

  """The counting number of words in this draft."""
  wordCount: Int!

  """Tags are attached to this draft."""
  tags: [String!]

  """Draft's cover link."""
  cover: String

  """State of draft during publihsing."""
  publishState: PublishState!

  """List of assets are belonged to this draft."""
  assets: [Asset!]!

  """Published article"""
  article: Article

  """Collection list of this draft."""
  collection(input: ConnectionArgs!): ArticleConnection!

  """Access related fields on circle"""
  access: DraftAccess!

  """License Type"""
  license: ArticleLicenseType!
}

type DraftConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DraftEdge!]
}

type DraftEdge {
  cursor: String!
  node: Draft!
}

type DraftAccess {
  type: ArticleAccessType!
  circle: Circle
}

input PutDraftInput {
  id: ID
  title: String
  summary: String
  content: String
  tags: [String]
  cover: ID
  collection: [ID]
  circle: ID
  accessType: ArticleAccessType

  """License Type, `ARR` is only for paywalled article"""
  license: ArticleLicenseType
}

input DeleteDraftInput {
  id: ID!
}

"""Enums for publishing state."""
enum PublishState {
  unpublished
  pending
  error
  published
}

"""This interface contains common fields of a notice."""
interface Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!
}

type NoticeConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [NoticeEdge!]
}

type NoticeEdge {
  cursor: String!
  node: Notice!
}

"""
################################
                               #
             User              #
                               #
################################
"""
type UserNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: UserNoticeType!
  target: User!
}

enum UserNoticeType {
  UserNewFollower
}

"""
################################
                               #
           Article             #
                               #
################################
"""
type ArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleNoticeType!
  target: Article!
}

enum ArticleNoticeType {
  ArticlePublished
  ArticleMentionedYou
  ArticleNewSubscriber
  ArticleNewAppreciation
  RevisedArticlePublished
  RevisedArticleNotPublished
  CircleNewArticle
}

type ArticleArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleArticleNoticeType!
  target: Article!
  article: Article!
}

enum ArticleArticleNoticeType {
  ArticleNewCollected
}

"""
################################
                               #
           Comment             #
                               #
################################
"""
type CommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentNoticeType!
  target: Comment!
}

enum CommentNoticeType {
  CommentPinned
  CommentMentionedYou
  ArticleNewComment
  SubscribedArticleNewComment
  CircleNewBroadcast
}

type CommentCommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentCommentNoticeType!
  target: Comment!
  comment: Comment!
}

enum CommentCommentNoticeType {
  CommentNewReply
}

"""
################################
                               #
             Tag               #
                               #
################################
"""
type ArticleTagNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleTagNoticeType!
  target: Article!
  tag: Tag!
}

enum ArticleTagNoticeType {
  ArticleTagAdded
  ArticleTagRemoved
  ArticleTagUnselected @deprecated(reason: "No longer in use")
}

type TagNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: TagNoticeType!
  target: Tag!
}

enum TagNoticeType {
  TagAdoption
  TagLeave
  TagAddEditor
  TagLeaveEditor
}

"""
################################
                               #
         Transaction           #
                               #
################################
"""
type TransactionNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: TransactionNoticeType!
  target: Transaction!
}

enum TransactionNoticeType {
  PaymentReceivedDonation
  PaymentPayout
}

"""
################################
                               #
            Circle             #
                               #
################################
"""
type CircleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CircleNoticeType!
  target: Circle!
}

enum CircleNoticeType {
  CircleNewFollower
  CircleNewSubscriber
  CircleNewUnsubscriber
  CircleInvitation
}

"""
################################
                               #
            Crypto             #
                               #
################################
"""
type CryptoNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CryptoNoticeType!
  target: CryptoWallet!
}

enum CryptoNoticeType {
  CryptoWalletAirdrop
  CryptoWalletConnected
}

"""The notice type contains info about official announcement."""
type OfficialAnnouncementNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """The message content."""
  message: String!

  """The link to a specific page if provided."""
  link: String
}

scalar DateTime

scalar Upload

interface Node {
  id: ID!
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

interface Connection {
  totalCount: Int!
  pageInfo: PageInfo!
}

"""This type contains system-wise info and settings."""
type Official {
  """Feature flag"""
  features: [Feature!]!

  """Announcements"""
  announcements(input: AnnouncementsInput!): [Announcement!]
}

type Feature {
  name: FeatureName!
  enabled: Boolean!
}

type Announcement {
  id: ID!
  title: String
  cover: String
  content: String
  link: String
  type: AnnouncementType!
  visible: Boolean!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OSS {
  users(input: ConnectionArgs!): UserConnection!
  comments(input: ConnectionArgs!): CommentConnection!
  articles(input: ConnectionArgs!): ArticleConnection!
  tags(input: TagsInput!): TagConnection!
  oauthClients(input: ConnectionArgs!): OAuthClientConnection!
  skippedListItems(input: SkippedListItemsInput!): SkippedListItemsConnection!
  seedingUsers(input: ConnectionArgs!): UserConnection!
  badgedUsers(input: BadgedUsersInput!): UserConnection!
}

"""This type contains type, link and related data of an asset."""
type Asset {
  """Unique ID of this Asset."""
  id: ID!

  """Types of this asset."""
  type: AssetType!

  """Link of this asset."""
  path: String!

  """Time of this asset was created."""
  createdAt: DateTime!
}

type SearchResultConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SearchResultEdge!]
}

type SearchResultEdge {
  cursor: String!
  node: Node!
}

input TagsInput {
  after: String
  first: Int
  sort: TagsSort
}

input SkippedListItemsInput {
  after: String
  first: Int
  type: SkippedListItemType
}

input BadgedUsersInput {
  after: String
  first: Int
  type: BadgeType
}

type SkippedListItemsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SkippedListItemEdge!]
}

type SkippedListItemEdge {
  cursor: String!
  node: SkippedListItem
}

type SkippedListItem {
  id: ID!
  uuid: ID!
  type: SkippedListItemType!
  value: String!
  archived: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input NodeInput {
  id: ID!
}

input NodesInput {
  ids: [ID!]!
}

input FrequentSearchInput {
  key: String
  first: Int
}

input SearchInput {
  """search keyword"""
  key: String!

  """types of search target"""
  type: SearchTypes!
  after: String
  first: Int

  """extra query filter for searching"""
  filter: SearchFilter

  """specific condition for rule data out"""
  exclude: SearchExclude

  """whether this search operation should be recorded in search history"""
  record: Boolean
  oss: Boolean
}

input SearchFilter {
  authorId: ID
}

input SingleFileUploadInput {
  type: AssetType!
  file: Upload
  url: String
  entityType: EntityType!
  entityId: ID
}

input SetBoostInput {
  id: ID!
  boost: Float!
  type: BoostTypes!
}

input PutRemarkInput {
  id: ID!
  remark: String!
  type: RemarkTypes!
}

input PutSkippedListItemInput {
  id: ID
  type: SkippedListItemType
  value: String
  archived: Boolean
}

input LogRecordInput {
  type: LogRecordTypes!
}

input ConnectionArgs {
  after: String
  first: Int
  oss: Boolean
}

"""Common input to toggle single item for `toggleXXX` mutations"""
input ToggleItemInput {
  id: ID!
  enabled: Boolean
}

input SetFeatureInput {
  name: FeatureName!
  flag: FeatureFlag!
}

input ToggleSeedingUsersInput {
  ids: [ID!]
  enabled: Boolean!
}

input AnnouncementsInput {
  id: ID
  visible: Boolean
}

input PutAnnouncementInput {
  id: ID
  title: String
  cover: String
  content: String
  link: String
  type: AnnouncementType
  visible: Boolean
  order: Int
}

input DeleteAnnouncementsInput {
  ids: [ID!]
}

enum SearchTypes {
  Article
  User
  Tag
}

enum BoostTypes {
  Article
  User
  Tag
}

enum RemarkTypes {
  Article
  User
  Tag
  Comment
  Report
  Feedback
}

enum LogRecordTypes {
  ReadFolloweeArticles
  ReadFollowingFeed
  ReadResponseInfoPopUp
}

"""Enums for sorting tags."""
enum TagsSort {
  newest
  oldest
  hottest
}

"""Enums for asset types."""
enum AssetType {
  avatar
  cover
  embed
  embedaudio
  profileCover
  oauthClientAvatar
  tagCover
  circleAvatar
  circleCover
  announcementCover
  topicCover

  """img-cached"""
  imgCached
}

enum EntityType {
  article
  draft
  tag
  user
  circle
  announcement
  topic
}

"""Enums for user roles."""
enum Role {
  vistor
  user
  admin
}

enum SkippedListItemType {
  agent_hash
  email
  domain
}

enum FeatureName {
  add_credit
  payment
  payout
  verify_appreciate
  fingerprint
  tag_adoption
  circle_management
  circle_interact
}

enum FeatureFlag {
  on
  off
  admin
  seeding
}

enum SearchExclude {
  blocked
}

enum AnnouncementType {
  community
  product
  seminar
}

"""
###################
    Directives    #
###################
"""
enum CacheControlScope {
  PUBLIC
  PRIVATE
}

input CostComplexity {
  min: Int = 1
  max: Int
}

type User implements Node {
  """Global id of an user."""
  id: ID!

  """Global unique user name of a user."""
  userName: String

  """Display name on user profile, can be duplicated."""
  displayName: String

  """LikerID of LikeCoin, being used by LikeCoin OAuth"""
  likerId: String

  """Liker info of current user"""
  liker: Liker!

  """URL for user avatar."""
  avatar: String

  """User information."""
  info: UserInfo!

  """User settings."""
  settings: UserSettings!

  """Article recommendations for current user."""
  recommendation: Recommendation!

  """Articles authored by current user."""
  articles(input: ConnectionArgs!): ArticleConnection!

  """Topics created by current user."""
  topics(input: TopicInput!): TopicConnection!

  """Tags owned and maintained by current user."""
  tags(input: ConnectionArgs!): TagConnection!

  """Drafts authored by current user."""
  drafts(input: ConnectionArgs!): DraftConnection!

  """Articles current user commented on"""
  commentedArticles(input: ConnectionArgs!): ArticleConnection!

  """Artilces current user subscribed to."""
  subscriptions(input: ConnectionArgs!): ArticleConnection!

  """Record of user activity, only accessable by current user."""
  activity: UserActivity!

  """Followers of this user."""
  followers(input: ConnectionArgs!): UserConnection!

  """Following contents of this user."""
  following: Following!

  """Whether current user is following viewer."""
  isFollower: Boolean!

  """Whether viewer is following current user."""
  isFollowee: Boolean!

  """Users that blocked by current user."""
  blockList(input: ConnectionArgs!): UserConnection!

  """Whether current user is blocking viewer."""
  isBlocking: Boolean!

  """Whether current user is blocked by viewer."""
  isBlocked: Boolean!

  """Status of current user."""
  status: UserStatus

  """
  #############
       OSS    #
  #############
  """
  oss: UserOSS!
  remark: String

  """Circles belong to current user."""
  ownCircles: [Circle!]

  """Circles whiches user has subscribed."""
  subscribedCircles(input: ConnectionArgs!): CircleConnection!
  notices(input: ConnectionArgs!): NoticeConnection!

  """User Wallet"""
  wallet: Wallet!

  """Payment pointer that resolves to Open Payments endpoints"""
  paymentPointer: String
}

type Recommendation {
  """Activities based on user's following, sort by creation time."""
  following(input: ConnectionArgs!): FollowingActivityConnection!

  """Articles recommended based on recently read article tags."""
  readTagsArticles(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "Merged into following")

  """Global articles sort by publish time."""
  newest(input: ConnectionArgs!): ArticleConnection!

  """Global articles sort by latest activity time."""
  hottest(input: ConnectionArgs!): ArticleConnection!

  """'In case you missed it' recommendation."""
  icymi(input: ConnectionArgs!): ArticleConnection!

  """Global tag list, sort by activities in recent 14 days."""
  tags(input: RecommendInput!): TagConnection!

  """Hottest tag list"""
  hottestTags(input: RecommendInput!): TagConnection!

  """Selected tag list"""
  selectedTags(input: RecommendInput!): TagConnection!

  """Global user list, sort by activities in recent 6 month."""
  authors(input: RecommendInput!): UserConnection!

  """Global circles sort by created time."""
  newestCircles(input: ConnectionArgs!): CircleConnection!

  """Global circles sort by latest activity time."""
  hottestCircles(input: ConnectionArgs!): CircleConnection!
}

input RecommendInput {
  after: String
  first: Int
  oss: Boolean
  filter: FilterInput
  type: AuthorsType
}

input TopicInput {
  after: String
  first: Int
  filter: FilterInput
}

input FilterInput {
  """index of list, min: 0, max: 49"""
  random: Int

  """Used in RecommendInput"""
  followed: Boolean

  """Used in User.topics"""
  public: Boolean
}

type UserInfo {
  """Timestamp of registration."""
  createdAt: DateTime

  """Is user name editable."""
  userNameEditable: Boolean!

  """User desciption."""
  description: String

  """User email."""
  email: String

  """User badges."""
  badges: [Badge!]

  """Timestamp of user agreement."""
  agreeOn: DateTime

  """Cover of profile page."""
  profileCover: String

  """Type of group."""
  group: UserGroup!

  """Connected wallet."""
  cryptoWallet: CryptoWallet
}

type UserSettings {
  """User language setting."""
  language: UserLanguage!

  """Notification settings."""
  notification: NotificationSetting!
}

type UserActivity {
  """User reading history."""
  history(input: ConnectionArgs!): ReadHistoryConnection!

  """User search history."""
  recentSearches(input: ConnectionArgs!): RecentSearchConnection!

  """Appreciations current user gave."""
  appreciationsSent(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user gave."""
  appreciationsSentTotal: Int!

  """Appreciations current user received."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user received."""
  appreciationsReceivedTotal: Int!
}

type UserStatus {
  """User state."""
  state: UserState!

  """User role and access level."""
  role: UserRole!

  """Number of articles published by user"""
  articleCount: Int!

  """Number of comments posted by user."""
  commentCount: Int!

  """Number of unread notices."""
  unreadNoticeCount: Int!

  """Whether there are unread activities from following."""
  unreadFollowing: Boolean!

  """Number of total written words."""
  totalWordCount: Int!

  """Whether user already set payment password."""
  hasPaymentPassword: Boolean!

  """Number of articles donated by user"""
  donatedArticleCount: Int!

  """Number of times of donations received by user"""
  receivedDonationCount: Int!
}

type Liker {
  """Liker ID of LikeCoin"""
  likerId: String

  """Whether liker is a civic liker"""
  civicLiker: Boolean!

  """Total LIKE left in wallet."""
  total: Float!

  """Rate of LikeCoin/USD"""
  rateUSD: Float
}

type UserOSS {
  boost: Float!
  score: Float!
}

type Appreciation {
  amount: Int!
  purpose: AppreciationPurpose!
  content: String!

  """Timestamp of appreciation."""
  createdAt: DateTime!

  """Recipient of appreciation."""
  recipient: User!

  """Sender of appreciation."""
  sender: User

  """Object that appreciation is meant for."""
  target: Article
}

type NotificationSetting {
  enable: Boolean!
  email: Boolean!
  mention: Boolean!
  userNewFollower: Boolean!
  articleNewComment: Boolean!
  articleNewAppreciation: Boolean!
  articleNewSubscription: Boolean!
  articleSubscribedNewComment: Boolean!
  articleCommentPinned: Boolean!
  circleNewFollower: Boolean!
  circleNewDiscussion: Boolean!
}

type ReadHistory {
  article: Article!
  readAt: DateTime!
}

type Badge {
  type: BadgeType!
}

type AuthResult {
  auth: Boolean!
  token: String
}

type UserConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [UserEdge!]
}

type UserEdge {
  cursor: String!
  node: User!
}

type ReadHistoryConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ReadHistoryEdge!]
}

type ReadHistoryEdge {
  cursor: String!
  node: ReadHistory!
}

type RecentSearchConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [RecentSearchEdge!]
}

type RecentSearchEdge {
  cursor: String!
  node: String!
}

type AppreciationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [AppreciationEdge!]
}

type AppreciationEdge {
  cursor: String!
  node: Appreciation!
}

type FollowingActivityConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [FollowingActivityEdge!]
}

type FollowingActivityEdge {
  cursor: String!
  node: FollowingActivity!
}

union FollowingActivity = UserPublishArticleActivity | UserAddArticleTagActivity | UserBroadcastCircleActivity | UserCreateCircleActivity | UserRecommendationActivity | ArticleRecommendationActivity | CircleRecommendationActivity

type UserPublishArticleActivity {
  actor: User!
  createdAt: DateTime!

  """Article published by actor"""
  node: Article!
}

type UserAddArticleTagActivity {
  actor: User!
  createdAt: DateTime!

  """Article added to tag"""
  node: Article!

  """Tag added by article"""
  target: Tag!
}

type UserBroadcastCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Comment boardcast by actor"""
  node: Comment!

  """Circle that comment belongs to"""
  target: Circle!
}

type UserCreateCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Circle created by actor"""
  node: Circle!
}

type UserRecommendationActivity {
  """The source type of recommendation"""
  source: UserRecommendationActivitySource

  """Recommended users"""
  nodes: [User!]
}

enum UserRecommendationActivitySource {
  UserFollowing
}

type ArticleRecommendationActivity {
  """The source type of recommendation"""
  source: ArticleRecommendationActivitySource

  """Recommended articles"""
  nodes: [Article!]
}

enum ArticleRecommendationActivitySource {
  UserDonation
  ReadArticlesTags
}

type CircleRecommendationActivity {
  """The source type of recommendation"""
  source: CircleRecommendationActivitySource

  """Recommended circles"""
  nodes: [Circle!]
}

enum CircleRecommendationActivitySource {
  UserSubscription
}

type Following {
  circles(input: ConnectionArgs!): CircleConnection!
  tags(input: ConnectionArgs!): TagConnection!
  users(input: ConnectionArgs!): UserConnection!
}

type CryptoWallet {
  id: ID!
  address: String!
  createdAt: DateTime!

  """NFT assets owned by this wallet address"""
  nfts: [NFTAsset!]
}

""" NFT Asset """
type NFTAsset {
  id: ID!
  name: String!
  description: String
  imageUrl: String!
  imagePreviewUrl: String
  imageOriginalUrl: String!
  contractAddress: String!
  collectionName: String!
  tokenMetadata: String
  openseaPermalink: String!
}

input UserInput {
  userName: String!
}

input SendVerificationCodeInput {
  email: String!
  type: VerificationCodeType!
  token: String

  """
  Redirect URL embedded in the verification email,
  use code instead if not provided.
  """
  redirectUrl: String
}

input ConfirmVerificationCodeInput {
  email: String!
  type: VerificationCodeType!
  code: String!
}

input ResetPasswordInput {
  password: String!
  codeId: ID!
  type: ResetPasswordType
}

input ChangeEmailInput {
  oldEmail: String!
  oldEmailCodeId: ID!
  newEmail: String!
  newEmailCodeId: ID!
}

input VerifyEmailInput {
  codeId: ID!
}

input UserRegisterInput {
  email: String!
  userName: String
  displayName: String!
  password: String!
  description: String
  codeId: ID!
}

input UserLoginInput {
  email: String!
  password: String!
}

input ResetLikerIdInput {
  id: ID!
}

input UpdateNotificationSettingInput {
  type: NotificationSettingType!
  enabled: Boolean!
}

input UpdateUserInfoInput {
  displayName: String
  userName: String
  avatar: ID
  description: String
  language: UserLanguage
  agreeOn: Boolean
  profileCover: ID
  paymentPassword: String
  paymentPointer: String
}

input UpdateUserStateInput {
  id: ID
  emails: [String!]
  state: UserState!
  banDays: Int
  password: String
}

input UpdateUserRoleInput {
  id: ID!
  role: UserRole!
}

input ToggleUsersBadgeInput {
  ids: [ID!]
  type: BadgeType!
  enabled: Boolean!
}

input ClearReadHistoryInput {
  id: ID!
}

input MigrationInput {
  type: MigrationType
  files: [Upload]!
}

input PutWalletInput {
  id: ID
  address: String!
  purpose: CryptoWalletSignaturePurpose!
  signedMessage: String!
  signature: String!
}

input DeleteWalletInput {
  id: ID!
}

enum BadgeType {
  seed
  golden_motor
  architect
}

enum VerificationCodeType {
  register
  email_reset
  email_reset_confirm
  password_reset
  payment_password_reset
}

enum ResetPasswordType {
  account
  payment
}

enum UserInfoFields {
  displayName
  avatar
  description
  email
  agreeOn
}

enum UserLanguage {
  en
  zh_hans
  zh_hant
}

enum NotificationSettingType {
  enable
  email
  mention
  userNewFollower
  articleNewComment
  articleNewAppreciation
  articleNewSubscription
  articleSubscribedNewComment
  articleCommentPinned
  circleNewFollower
  circleNewDiscussion
}

enum UserState {
  active
  onboarding
  banned
  archived
  frozen
}

enum UserRole {
  user
  admin
}

enum UserGroup {
  a
  b
}

enum AppreciationPurpose {
  appreciate
  appreciateComment
  appreciateSubsidy
  invitationAccepted
  joinByInvitation
  joinByTask
  firstPost
  systemSubsidy
}

enum MigrationType {
  medium
}

enum AuthorsType {
  active
  appreciated
  default
  trendy
}

enum CryptoWalletSignaturePurpose {
  airdrop
  connect
}

union Response = Article | Comment

type ResponseConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ResponseEdge!]
}

type ResponseEdge {
  cursor: String!
  node: Response!
}

input ResponsesInput {
  sort: ResponseSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: Int
  articleOnly: Boolean
}

"""Enums for sorting responses."""
enum ResponseSort {
  oldest
  newest
}

union TransactionTarget = Article | Circle | Transaction

type Wallet {
  balance: Balance!
  transactions(input: TransactionsArgs!): TransactionConnection!

  """Account of Stripe Connect to manage payout"""
  stripeAccount: StripeAccount

  """
  URL of Stripe Dashboard to manage subscription invoice and payment method
  """
  customerPortal: String

  """The last four digits of the card."""
  cardLast4: String
}

type Balance {
  HKD: Float!
}

type Transaction {
  id: ID!
  state: TransactionState!
  purpose: TransactionPurpose!
  amount: Float!
  fee: Float!
  currency: TransactionCurrency!

  """Timestamp of transaction."""
  createdAt: DateTime!

  """Recipient of transaction."""
  recipient: User

  """Sender of transaction."""
  sender: User

  """Related target article or transaction."""
  target: TransactionTarget

  """Message for end user, including reason of failure."""
  message: String
}

type TransactionConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TransactionEdge!]
}

type TransactionEdge {
  cursor: String!
  node: Transaction!
}

input TransactionsArgs {
  after: String
  first: Int
  id: ID
  states: [TransactionState!]
}

enum TransactionState {
  pending
  succeeded
  failed
  canceled
}

enum TransactionPurpose {
  donation
  addCredit
  refund
  payout
  subscriptionSplit
}

enum TransactionCurrency {
  HKD
  LIKE
}

type AddCreditResult {
  transaction: Transaction!

  """The client secret of this PaymentIntent."""
  client_secret: String!
}

type PayToResult {
  transaction: Transaction!

  """Only available when paying with LIKE."""
  redirectUrl: String
}

"""Add Credit"""
input AddCreditInput {
  amount: Float!
}

input PayToInput {
  amount: Float!
  currency: TransactionCurrency!
  purpose: TransactionPurpose!
  recipientId: ID!
  targetId: ID
  password: String
}

input PayoutInput {
  amount: Float!
  password: String!
}

"""Stripe Account"""
input ConnectStripeAccountInput {
  country: StripeAccountCountry!
}

type StripeAccount {
  id: ID!
  loginUrl: String!
}

type ConnectStripeAccountResult {
  redirectUrl: String!
}

enum StripeAccountCountry {
  Australia
  Austria
  Belgium
  Bulgaria
  Canada
  Cyprus
  Denmark
  Estonia
  Finland
  France
  Germany
  Greece
  HongKong
  Ireland
  Italy
  Latvia
  Lithuania
  Luxembourg
  Malta
  Netherlands
  NewZealand
  Norway
  Poland
  Portugal
  Romania
  Singapore
  Slovakia
  Slovenia
  Spain
  Sweden
  UnitedKingdom
  UnitedStates
}

type OAuthClient {
  """Unique Client ID of this OAuth Client."""
  id: ID!

  """App name"""
  name: String!

  """App Description"""
  description: String

  """URL for oauth client's official website"""
  website: String

  """Scopes"""
  scope: [String!]

  """URL for oauth client's avatar."""
  avatar: String

  """Client secret"""
  secret: String!

  """Redirect URIs"""
  redirectURIs: [String!]

  """Grant Types"""
  grantTypes: [GrantType!]

  """Linked Developer Account"""
  user: User

  """Creation Date"""
  createdAt: DateTime!
}

type OAuthClientConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [OAuthClientEdge!]
}

type OAuthClientEdge {
  cursor: String!
  node: OAuthClient!
}

input OAuthClientInput {
  id: ID!
}

input PutOAuthClientInput {
  id: ID
  name: String
  description: String
  website: String
  scope: [String!]
  avatar: ID
  secret: String
  redirectURIs: [String!]
  grantTypes: [GrantType!]
  user: ID
}

enum GrantType {
  authorization_code
  refresh_token
}
