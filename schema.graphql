directive @constraint(minLength: Int, maxLength: Int, startsWith: String, endsWith: String, contains: String, notContains: String, pattern: String, format: String, min: Float, max: Float, exclusiveMin: Float, exclusiveMax: Float, multipleOf: Float, minItems: Int, maxItems: Int, uniqueTypeName: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION | ARGUMENT_DEFINITION

directive @auth(mode: String!, group: String) on FIELD_DEFINITION

"""Rate limit within a given period of time, in seconds"""
directive @rateLimit(period: Int!, limit: Int!) on FIELD_DEFINITION

directive @privateCache(strict: Boolean! = false) on FIELD_DEFINITION

directive @objectCache(maxAge: Int = 1000) on FIELD_DEFINITION

directive @logCache(type: String!, identifier: String = "id") on FIELD_DEFINITION

directive @purgeCache(type: String!, identifier: String = "id") on FIELD_DEFINITION

directive @cacheControl(maxAge: Int, scope: CacheControlScope, inheritMaxAge: Boolean) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

directive @complexity(value: Int!, multipliers: [String!]) on FIELD_DEFINITION

type Query {
  article(input: ArticleInput!): Article
  campaign(input: CampaignInput!): Campaign
  campaigns(input: CampaignsInput!): CampaignConnection!
  circle(input: CircleInput!): Circle
  node(input: NodeInput!): Node
  nodes(input: NodesInput!): [Node!]
  frequentSearch(input: FrequentSearchInput!): [String!]
  search(input: SearchInput!): SearchResultConnection!
  official: Official!
  oss: OSS!
  viewer: User
  user(input: UserInput!): User
  oauthRequestToken: String
  exchangeRates(input: ExchangeRatesInput): [ExchangeRate!]
  oauthClient(input: OAuthClientInput!): OAuthClient
  moment(input: MomentInput!): Moment
  channel(input: ChannelInput!): Channel
  channels(input: ChannelsInput): [Channel!]!
}

type Mutation {
  """Publish an article onto IPFS."""
  publishArticle(input: PublishArticleInput!): Draft!

  """Edit an article."""
  editArticle(input: EditArticleInput!): Article!

  """Bookmark or unbookmark article"""
  toggleSubscribeArticle(input: ToggleItemInput!): Article! @deprecated(reason: "Use toggleBookmarkArticle instead")
  toggleBookmarkArticle(input: ToggleItemInput!): Article!

  """Appreciate an article."""
  appreciateArticle(input: AppreciateArticleInput!): Article!

  """Read an article."""
  readArticle(input: ReadArticleInput!): Article!

  """Feedback on topic channel classification"""
  submitTopicChannelFeedback(input: SubmitTopicChannelFeedbackInput!): TopicChannelFeedback!

  """Bookmark or unbookmark tag."""
  toggleFollowTag(input: ToggleItemInput!): Tag! @deprecated(reason: "Use toggleBookmarkTag instead")
  toggleBookmarkTag(input: ToggleItemInput!): Tag!
  toggleArticleRecommend(input: ToggleRecommendInput!): Article!
  updateArticleState(input: UpdateArticleStateInput!): Article!
  updateArticleSensitive(input: UpdateArticleSensitiveInput!): Article!
  deleteTags(input: DeleteTagsInput!): Boolean
  renameTag(input: RenameTagInput!): Tag!
  mergeTags(input: MergeTagsInput!): Tag!
  putWritingChallenge(input: PutWritingChallengeInput!): WritingChallenge!
  applyCampaign(input: ApplyCampaignInput!): Campaign!
  updateCampaignApplicationState(input: UpdateCampaignApplicationStateInput!): Campaign!
  toggleWritingChallengeFeaturedArticles(input: ToggleWritingChallengeFeaturedArticlesInput!): Campaign!
  banCampaignArticles(input: BanCampaignArticlesInput!): Campaign!
  sendCampaignAnnouncement(input: SendCampaignAnnouncementInput!): Boolean

  """Create or update a Circle."""
  putCircle(input: PutCircleInput!): Circle!

  """Follow or unfollow a Circle."""
  toggleFollowCircle(input: ToggleItemInput!): Circle! @deprecated(reason: "No longer in use")

  """Subscribe a Circle."""
  subscribeCircle(input: SubscribeCircleInput!): SubscribeCircleResult!

  """Unsubscribe a Circle."""
  unsubscribeCircle(input: UnsubscribeCircleInput!): Circle!

  """Add or remove Circle's articles"""
  putCircleArticles(input: PutCircleArticlesInput!): Circle! @deprecated(reason: "No longer in use")

  """Invite others to join circle"""
  invite(input: InviteCircleInput!): [Invitation!]

  """Publish or update a comment."""
  putComment(input: PutCommentInput!): Comment!

  """Remove a comment."""
  deleteComment(input: DeleteCommentInput!): Comment!

  """Pin or Unpin a comment."""
  togglePinComment(input: ToggleItemInput!): Comment!

  """Upvote or downvote a comment."""
  voteComment(input: VoteCommentInput!): Comment!

  """Unvote a comment."""
  unvoteComment(input: UnvoteCommentInput!): Comment!

  """Update a comments' state."""
  updateCommentsState(input: UpdateCommentsStateInput!): [Comment!]!

  """Pin a comment."""
  pinComment(input: PinCommentInput!): Comment!

  """Unpin a comment."""
  unpinComment(input: UnpinCommentInput!): Comment!

  """Create or update a draft."""
  putDraft(input: PutDraftInput!): Draft!

  """Remove a draft."""
  deleteDraft(input: DeleteDraftInput!): Boolean

  """Mark all received notices as read."""
  markAllNoticesAsRead: Boolean

  """Upload a single file."""
  singleFileUpload(input: SingleFileUploadInput!): Asset!
  directImageUpload(input: DirectImageUploadInput!): Asset!

  """Add specific user behavior record."""
  logRecord(input: LogRecordInput!): Boolean

  """Add blocked search keyword to blocked_search_word db"""
  addBlockedSearchKeyword(input: KeywordInput!): BlockedSearchKeyword!

  """Delete blocked search keywords from search_history db"""
  deleteBlockedSearchKeywords(input: KeywordsInput!): Boolean

  """Submit inappropriate content report"""
  submitReport(input: SubmitReportInput!): Report!
  setBoost(input: SetBoostInput!): Node!
  putRemark(input: PutRemarkInput!): String
  putSkippedListItem(input: PutSkippedListItemInput!): [SkippedListItem!]
  setFeature(input: SetFeatureInput!): Feature!
  toggleSeedingUsers(input: ToggleSeedingUsersInput!): [User]!
  putAnnouncement(input: PutAnnouncementInput!): Announcement!
  deleteAnnouncements(input: DeleteAnnouncementsInput!): Boolean!
  putRestrictedUsers(input: PutRestrictedUsersInput!): [User!]!
  putUserFeatureFlags(input: PutUserFeatureFlagsInput!): [User!]!
  putIcymiTopic(input: PutIcymiTopicInput!): IcymiTopic
  setSpamStatus(input: SetSpamStatusInput!): Article!
  setAdStatus(input: SetAdStatusInput!): Article!
  reviewTopicChannelFeedback(input: ReviewTopicChannelFeedbackInput!): TopicChannelFeedback!

  """Send verification code for email."""
  sendVerificationCode(input: SendVerificationCodeInput!): Boolean

  """Confirm verification code from email."""
  confirmVerificationCode(input: ConfirmVerificationCodeInput!): ID!

  """Reset user or payment password."""
  resetPassword(input: ResetPasswordInput!): Boolean

  """Set user email."""
  setEmail(input: SetEmailInput!): User!

  """Verify user email."""
  verifyEmail(input: VerifyEmailInput!): AuthResult!

  """Set user currency preference."""
  setCurrency(input: SetCurrencyInput!): User!

  """Login user."""
  emailLogin(input: EmailLoginInput!): AuthResult!

  """Get signing message."""
  generateSigningMessage(input: GenerateSigningMessageInput!): SigningMessageResult!

  """Login/Signup via a wallet."""
  walletLogin(input: WalletLoginInput!): AuthResult!

  """Add a wallet login to current user."""
  addWalletLogin(input: WalletLoginInput!): User!

  """Remove a wallet login from current user."""
  removeWalletLogin: User!

  """Login/Signup via social accounts."""
  socialLogin(input: SocialLoginInput!): AuthResult!

  """Add a social login to current user."""
  addSocialLogin(input: SocialLoginInput!): User!

  """Remove a social login from current user."""
  removeSocialLogin(input: RemoveSocialLoginInput!): User!

  """Logout user."""
  userLogout: Boolean!

  """Reset Liker ID"""
  resetLikerId(input: ResetLikerIdInput!): User!

  """Update user information."""
  updateUserInfo(input: UpdateUserInfoInput!): User!

  """Set user name."""
  setUserName(input: SetUserNameInput!): User!

  """Set user email login password."""
  setPassword(input: SetPasswordInput!): User!

  """Update user notification settings."""
  updateNotificationSetting(input: UpdateNotificationSettingInput!): User!

  """Follow or Unfollow current user."""
  toggleFollowUser(input: ToggleItemInput!): User!

  """Block or Unblock a given user."""
  toggleBlockUser(input: ToggleItemInput!): User!

  """Clear read history for user."""
  clearReadHistory(input: ClearReadHistoryInput!): User!

  """Clear search history for user."""
  clearSearchHistory: Boolean

  """Migrate articles from other service provider."""
  migration(input: MigrationInput!): Boolean

  """Let Traveloggers owner claims a Logbook, returns transaction hash"""
  claimLogbooks(input: ClaimLogbooksInput!): ClaimLogbooksResult!

  """update tags for showing on profile page"""
  putFeaturedTags(input: FeaturedTagsInput!): [Tag!]

  """Update state of a user, used in OSS."""
  updateUserState(input: UpdateUserStateInput!): [User!]

  """Update state of a user, used in OSS."""
  updateUserRole(input: UpdateUserRoleInput!): User!

  """Update referralCode of a user, used in OSS."""
  updateUserExtra(input: UpdateUserExtraInput!): User!
  toggleUsersBadge(input: ToggleUsersBadgeInput!): [User]!
  unbindLikerId(input: UnbindLikerIdInput!): User!

  """Add Credit to User Wallet"""
  addCredit(input: AddCreditInput!): AddCreditResult!

  """Pay to another user or article"""
  payTo(input: PayToInput!): PayToResult!

  """Payout to user"""
  payout(input: PayoutInput!): Transaction!

  """Create Stripe Connect account for Payout"""
  connectStripeAccount(input: ConnectStripeAccountInput!): ConnectStripeAccountResult!

  """Withdraw locked ERC20/native token from donation vault"""
  withdrawLockedTokens: WithdrawLockedTokensResult!

  """Create or Update an OAuth Client, used in OSS."""
  putOAuthClient(input: PutOAuthClientInput!): OAuthClient
  putCollection(input: PutCollectionInput!): Collection!
  deleteCollections(input: DeleteCollectionsInput!): Boolean!

  """Add articles to the begining of the collections."""
  addCollectionsArticles(input: AddCollectionsArticlesInput!): [Collection!]!

  """Remove articles from the collection."""
  deleteCollectionArticles(input: DeleteCollectionArticlesInput!): Collection!

  """Reorder articles in the collection."""
  reorderCollectionArticles(input: ReorderCollectionArticlesInput!): Collection!
  likeCollection(input: LikeCollectionInput!): Collection!
  unlikeCollection(input: UnlikeCollectionInput!): Collection!
  putMoment(input: PutMomentInput!): Moment!
  deleteMoment(input: DeleteMomentInput!): Moment!
  likeMoment(input: LikeMomentInput!): Moment!
  unlikeMoment(input: UnlikeMomentInput!): Moment!
  putTopicChannel(input: PutTopicChannelInput!): TopicChannel!
  putCurationChannel(input: PutCurationChannelInput!): CurationChannel!
  setArticleTopicChannels(input: SetArticleTopicChannelsInput!): Article!
  addCurationChannelArticles(input: AddCurationChannelArticlesInput!): CurationChannel!
  deleteCurationChannelArticles(input: DeleteCurationChannelArticlesInput!): CurationChannel!
  togglePinChannelArticles(input: TogglePinChannelArticlesInput!): [Channel!]!
  reorderChannels(input: ReorderChannelsInput!): Boolean!
  classifyArticlesChannels(input: ClassifyArticlesChannelsInput!): Boolean!
}

"""
This type contains metadata, content, hash and related data of an article. If you
want information about article's comments. Please check Comment type.
"""
type Article implements Node & PinnableWork {
  """Unique ID of this article"""
  id: ID!

  """Slugified article title."""
  slug: String!

  """Time of this article was created."""
  createdAt: DateTime!

  """Time of this article was revised."""
  revisedAt: DateTime

  """State of this article."""
  state: ArticleState!

  """Author of this article."""
  author: User!

  """Article title."""
  title: String!

  """Article cover's link, set by author"""
  cover: String

  """Cover link that is displayed on the article page"""
  displayCover: String

  """
  List of assets are belonged to this article (Only the author can access currently).
  """
  assets: [Asset!]!

  """A short summary for this article."""
  summary: String!

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Tags attached to this article."""
  tags: [Tag!]

  """Word count of this article."""
  wordCount: Int

  """IPFS hash of this article."""
  dataHash: String!

  """Media hash, composed of cid encoding, of this article."""
  mediaHash: String!

  """Short hash for shorter url addressing"""
  shortHash: String!

  """Content (HTML) of this article."""
  content: String!

  """Different foramts of content."""
  contents: ArticleContents!

  """Original language of content"""
  language: String

  """List of articles which added this article into their connections."""
  connectedBy(input: ConnectionArgs!): ArticleConnection!

  """List of articles added into this article's connections."""
  collection(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "Use connections instead")
  connections(input: ConnectionArgs!): ArticleConnection!

  """Collections of this article."""
  collections(input: ConnectionArgs!): CollectionConnection!

  """Related articles to this article."""
  relatedArticles(input: ConnectionArgs!): ArticleConnection!

  """Donation-related articles to this article."""
  relatedDonationArticles(input: RelatedDonationArticlesInput!): ArticleConnection!

  """Appreciations history of this article."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciations recieved of this article."""
  appreciationsReceivedTotal: Int!

  """Total number of donation recieved of this article."""
  donationCount: Int!

  """Total number of readers of this article."""
  readerCount: Int!

  """Limit the nuhmber of appreciate per user."""
  appreciateLimit: Int!

  """Number represents how many times per user can appreciate this article."""
  appreciateLeft: Int!

  """This value determines if current viewer has appreciated or not."""
  hasAppreciate: Boolean!

  """This value determines if current viewer can SuperLike or not."""
  canSuperLike: Boolean!

  """This value determines if current Viewer has bookmarked of not."""
  subscribed: Boolean! @deprecated(reason: "Use bookmarked instead")
  bookmarked: Boolean!

  """The number of users who bookmarked this article."""
  bookmarkCount: Int!

  """
  This value determines if this article is an author selected article or not.
  """
  pinned: Boolean!

  """Translation of article title and content."""
  translation(input: ArticleTranslationInput): ArticleTranslation

  """Available translation languages."""
  availableTranslations: [UserLanguage!]

  """Transactions history of this article."""
  transactionsReceivedBy(input: TransactionsReceivedByArgs!): UserConnection!

  """Donations of this article, grouped by sender"""
  donations(input: ConnectionArgs!): ArticleDonationConnection!

  """Cumulative reading time in seconds"""
  readTime: Float!

  """Revision Count"""
  revisionCount: Int!

  """Access related fields on circle"""
  access: ArticleAccess!

  """whether content is marked as sensitive by author"""
  sensitiveByAuthor: Boolean!

  """Whether content is marked as sensitive by admin"""
  sensitiveByAdmin: Boolean!

  """License Type"""
  license: ArticleLicenseType!

  """Whether current viewer has donated to this article"""
  donated: Boolean!

  """Creator message asking for support"""
  requestForDonation: String

  """Creator message after support"""
  replyToDonator: String

  """The iscnId if published to ISCN"""
  iscnId: String

  """Whether readers can comment"""
  canComment: Boolean!

  """Whether the first line of paragraph should be indented"""
  indentFirstLine: Boolean!

  """History versions"""
  versions(input: ArticleVersionsInput!): ArticleVersionsConnection!

  """Associated campaigns"""
  campaigns: [ArticleCampaign!]!

  """Whether this article is noindex"""
  noindex: Boolean!

  """Classifications status"""
  classification: ArticleClassification!
  oss: ArticleOSS!
  remark: String

  """The counting number of comments."""
  commentCount: Int!

  """The number determines how many pinned comments can be set."""
  pinCommentLimit: Int!

  """The number determines how many comments can be set as pinned comment."""
  pinCommentLeft: Int!

  """List of pinned comments."""
  pinnedComments: [Comment!]

  """List of featured comments of this article."""
  featuredComments(input: FeaturedCommentsInput!): CommentConnection!

  """List of comments of this article."""
  comments(input: CommentsInput!): CommentConnection!

  """The counting number of this article."""
  responseCount: Int!

  """List of responses of a article."""
  responses(input: ResponsesInput!): ResponseConnection!
}

type ArticleClassification {
  topicChannel: TopicChannelClassification!
}

type TopicChannelClassification {
  """whether user enable channel classification"""
  enable: Boolean!

  """
  Which channels this article is in, null for not classified, empty for not in any channel
  """
  channels: [ArticleTopicChannel!]

  """Feedback from author"""
  feedback: TopicChannelFeedback
}

input SubmitTopicChannelFeedbackInput {
  article: ID!
  type: TopicChannelFeedbackType!
  channels: [ID!]
}

type ArticleCampaign {
  campaign: Campaign!
  stage: CampaignStage
}

input ArticleVersionsInput {
  after: String
  first: Int
}

type ArticleVersionsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleVersionEdge]!
}

type ArticleVersionEdge {
  node: ArticleVersion!
  cursor: String!
}

type ArticleVersion implements Node {
  id: ID!
  dataHash: String
  mediaHash: String
  title: String!
  summary: String!
  contents: ArticleContents!
  translation(input: ArticleTranslationInput): ArticleTranslation
  createdAt: DateTime!
  description: String
}

"""This type contains content, count and related data of an article tag."""
type Tag implements Node {
  """Unique id of this tag."""
  id: ID!

  """Content of this tag."""
  content: String!

  """List of how many articles were attached with this tag."""
  articles(input: TagArticlesInput!): ArticleConnection!

  """Time of this tag was created."""
  createdAt: DateTime!

  """This value determines if current viewer is following or not."""
  isFollower: Boolean

  """Tags recommended based on relations to current tag."""
  recommended(input: RecommendInput!): TagConnection!

  """Authors recommended based on relations to current tag."""
  recommendedAuthors(input: ConnectionArgs!): UserConnection!

  """Counts of this tag."""
  numArticles: Int!
  numAuthors: Int!
  oss: TagOSS!
  remark: String
  deleted: Boolean!
}

type ArticleContents {
  """Markdown content of this article."""
  markdown: String!

  """HTML content of this article."""
  html: String!
}

type ArticleAccess {
  type: ArticleAccessType!
  secret: String
  circle: Circle
}

type ArticleOSS {
  boost: Float!
  score: Float!
  inRecommendIcymi: Boolean!
  inRecommendHottest: Boolean!
  inRecommendNewest: Boolean!
  inSearch: Boolean!
  spamStatus: SpamStatus!
  adStatus: AdStatus!
  topicChannels: [ArticleTopicChannel!] @deprecated(reason: "Use classification.topicChannel.channels instead")
}

type SpamStatus {
  """Spam confident score by machine, null for not checked yet. """
  score: Float

  """
  Whether this article is labeled as spam by human, null for not labeled yet. 
  """
  isSpam: Boolean
}

type AdStatus {
  """
  Whether this article is labeled as ad by human, null for not labeled yet. 
  """
  isAd: Boolean
}

type ArticleTopicChannel {
  channel: TopicChannel!

  """Confident score by machine"""
  score: Float

  """Whether this article is labeled by human, null for not labeled yet. """
  isLabeled: Boolean!

  """Whether this article channel is enabled"""
  enabled: Boolean!

  """Whether this article is pinned"""
  pinned: Boolean!

  """Datetime when this article is classified"""
  classicfiedAt: DateTime!

  """Whether this article is filtered out by anti-flood in this channel"""
  antiFlooded: Boolean!
}

enum TranslationModel {
  google_translation_v2
  google_gemini_2_5_flash
  google_gemini_2_0_flash
  opencc
}

type ArticleTranslation {
  title: String
  content: String
  summary: String
  language: String
  model: TranslationModel
}

input ArticleTranslationInput {
  language: UserLanguage!
  model: TranslationModel
}

input TranslationArgs {
  language: UserLanguage!
}

type TagOSS {
  boost: Float!
  score: Float!
}

type ArticleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleEdge!]
}

type ArticleEdge {
  cursor: String!
  node: Article!
}

type TagConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TagEdge!]
}

type TagEdge {
  cursor: String!
  node: Tag!
}

type ArticleDonationConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ArticleDonationEdge!]
}

type ArticleDonationEdge {
  cursor: String!
  node: ArticleDonation!
}

type ArticleDonation {
  id: ID!
  sender: User
}

input ArticleInput {
  mediaHash: String
  shortHash: String
}

input PublishArticleInput {
  id: ID!

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """Scheduled publish date of the article."""
  publishAt: DateTime
}

input EditArticleInput {
  id: ID!
  state: ArticleState
  pinned: Boolean
  title: String
  summary: String
  tags: [String!]
  content: String
  cover: ID

  """Deprecated, use connections instead"""
  collection: [ID!]
  connections: [ID!]
  collections: [ID!]
  circle: ID
  accessType: ArticleAccessType
  sensitive: Boolean
  license: ArticleLicenseType
  indentFirstLine: Boolean
  requestForDonation: String
  replyToDonator: String

  """revision description"""
  description: String

  """whether publish to ISCN"""
  iscnPublish: Boolean

  """whether readers can comment"""
  canComment: Boolean

  """which campaigns to attach"""
  campaigns: [ArticleCampaignInput!]
}

input ArticleCampaignInput {
  campaign: ID!
  stage: ID
}

input AppreciateArticleInput {
  id: ID!
  amount: Int!
  token: String
  superLike: Boolean
}

input ReadArticleInput {
  id: ID!
}

input ToggleRecommendInput {
  id: ID!
  enabled: Boolean!
  type: RecommendTypes
}

input UpdateArticleStateInput {
  id: ID!
  state: ArticleState!
}

input UpdateArticleSensitiveInput {
  id: ID!
  sensitive: Boolean!
}

input DeleteTagsInput {
  ids: [ID!]!
}

input RenameTagInput {
  id: ID!
  content: String!
}

input MergeTagsInput {
  ids: [ID!]!
  content: String!
}

enum TagArticlesSortBy {
  byHottestDesc
  byCreatedAtDesc
}

input TagArticlesInput {
  after: String
  first: Int
  oss: Boolean
  sortBy: TagArticlesSortBy = byCreatedAtDesc
}

input TransactionsReceivedByArgs {
  after: String
  first: Int
  purpose: TransactionPurpose!
  senderId: ID
}

input RelatedDonationArticlesInput {
  after: String
  first: Int
  oss: Boolean

  """index of article list, min: 0, max: 49"""
  random: Int
}

"""Enums for an article state."""
enum ArticleState {
  active
  archived
  banned
}

"""Enums for types of article access"""
enum ArticleAccessType {
  public
  paywall
}

"""Enums for types of article license"""
enum ArticleLicenseType {
  cc_0
  cc_by_nc_nd_2
  cc_by_nc_nd_4
  arr
}

"""Enums for types of recommend articles."""
enum RecommendTypes {
  icymi
  hottest
  newest
  search
}

enum ArticlesSort {
  newest
  mostAppreciations
  mostBookmarks
  mostComments
  mostDonations
  mostReadTime
}

input CampaignInput {
  shortHash: String!
}

input CampaignsInput {
  after: String
  first: Int

  """return pending and archived campaigns"""
  oss: Boolean = false
}

input PutWritingChallengeInput {
  id: ID
  name: [TranslationInput!]
  navbarTitle: [TranslationInput!]
  cover: ID
  description: [TranslationInput!]
  link: String
  announcements: [ID!]
  applicationPeriod: DatetimeRangeInput
  writingPeriod: DatetimeRangeInput
  stages: [CampaignStageInput!]
  newStages: [CampaignStageInput!]
  state: CampaignState
  featuredDescription: [TranslationInput!]
  channelEnabled: Boolean

  """exclude articles of this campaign in topic channels and newest"""
  exclusive: Boolean
  managers: [ID!]
}

input ApplyCampaignInput {
  id: ID!
}

input UpdateCampaignApplicationStateInput {
  campaign: ID!
  user: ID!
  state: CampaignApplicationState!
}

input ToggleWritingChallengeFeaturedArticlesInput {
  campaign: ID!
  articles: [ID!]!
  enabled: Boolean!
}

input BanCampaignArticlesInput {
  campaign: ID!
  articles: [ID!]!
}

input SendCampaignAnnouncementInput {
  campaign: ID!
  announcement: [TranslationInput!]!
  link: String!
  password: String!
}

input CampaignStageInput {
  name: [TranslationInput!]!
  description: [TranslationInput!]
  period: DatetimeRangeInput
}

input TranslationInput {
  language: UserLanguage!
  text: String!
}

input DatetimeRangeInput {
  start: DateTime!
  end: DateTime
}

interface Campaign {
  id: ID!
  shortHash: String!
  name: String!
  state: CampaignState!
}

enum CampaignState {
  pending
  active
  finished
  archived
}

type WritingChallenge implements Node & Campaign & Channel {
  id: ID!
  shortHash: String!
  navbarTitle(input: TranslationArgs): String!
  channelEnabled: Boolean!
  name(input: TranslationArgs): String!
  description(input: TranslationArgs): String
  cover: String
  link: String!
  announcements: [Article!]!
  applicationPeriod: DatetimeRange
  writingPeriod: DatetimeRange
  stages: [CampaignStage!]!
  state: CampaignState!
  participants(input: CampaignParticipantsInput!): CampaignParticipantConnection!
  articles(input: CampaignArticlesInput!): CampaignArticleConnection!
  application: CampaignApplication
  featuredDescription(input: TranslationArgs): String!
  isManager: Boolean!
  oss: CampaignOSS!
}

type CampaignOSS {
  managers: [User!]!
  boost: Float!
  exclusive: Boolean!
}

type CampaignApplication {
  state: CampaignApplicationState!
  createdAt: DateTime!
}

type CampaignParticipantConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CampaignParticipantEdge!]
}

type CampaignParticipantEdge {
  cursor: String!
  application: CampaignApplication
  node: User!
}

type CampaignArticleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CampaignArticleEdge!]!
}

type CampaignArticleEdge {
  cursor: String!
  node: Article!
  featured: Boolean!
  announcement: Boolean!
}

input CampaignParticipantsInput {
  after: String
  first: Int

  """return all state participants"""
  oss: Boolean = false
}

type DatetimeRange {
  start: DateTime!
  end: DateTime
}

enum CampaignApplicationState {
  pending
  succeeded
  rejected
}

type CampaignStage {
  id: ID!
  name(input: TranslationArgs): String!
  description(input: TranslationArgs): String!
  period: DatetimeRange
}

input CampaignArticlesInput {
  after: String
  first: Int
  filter: CampaignArticlesFilter
}

input CampaignArticlesFilter {
  stage: ID
  featured: Boolean
}

type CampaignConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CampaignEdge!]
}

type CampaignEdge {
  cursor: String!
  node: Campaign!
}

type Circle implements Node {
  """Unique ID."""
  id: ID!

  """Circle avatar's link."""
  avatar: String @deprecated(reason: "No longer in use")

  """Circle cover's link."""
  cover: String @deprecated(reason: "No longer in use")

  """Slugified name of this Circle."""
  name: String! @deprecated(reason: "No longer in use")

  """Human readable name of this Circle."""
  displayName: String! @deprecated(reason: "No longer in use")

  """A short description of this Circle."""
  description: String

  """Prices offered by this Circle."""
  prices: [Price!]

  """Circle owner."""
  owner: User!

  """List of Circle member."""
  members(input: ConnectionArgs!): MemberConnection! @deprecated(reason: "No longer in use")

  """List of Circle follower."""
  followers(input: ConnectionArgs!): UserConnection! @deprecated(reason: "No longer in use")

  """List of works belong to this Circle."""
  works(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "No longer in use")

  """State of this Circle."""
  state: CircleState! @deprecated(reason: "No longer in use")

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is following Circle or not."""
  isFollower: Boolean! @deprecated(reason: "No longer in use")

  """This value determines if current viewer is Member or not."""
  isMember: Boolean! @deprecated(reason: "No longer in use")

  """Invitations belonged to this Circle."""
  invites: Invites!

  """Invitation used by current viewer."""
  invitedBy: Invitation

  """Analytics dashboard."""
  analytics: CircleAnalytics!

  """Comments broadcasted by Circle owner."""
  broadcast(input: CommentsInput!): CommentConnection!

  """Pinned comments broadcasted by Circle owner."""
  pinnedBroadcast: [Comment!]

  """Comments made by Circle member."""
  discussion(input: CommentsInput!): CommentConnection!

  """Discussion (exclude replies) count of this circle."""
  discussionThreadCount: Int!

  """Discussion (include replies) count of this circle."""
  discussionCount: Int!
}

type User implements Node {
  """Circles belong to current user."""
  ownCircles: [Circle!]

  """Circles whiches user has subscribed."""
  subscribedCircles(input: ConnectionArgs!): CircleConnection!
  notices(input: ConnectionArgs!): NoticeConnection!

  """Global id of an user."""
  id: ID!

  """Global unique user name of a user."""
  userName: String

  """Display name on user profile, can be duplicated."""
  displayName: String

  """LikerID of LikeCoin, being used by LikeCoin OAuth"""
  likerId: String

  """Liker info of current user"""
  liker: Liker!

  """URL for user avatar."""
  avatar: String

  """User information."""
  info: UserInfo!

  """User settings."""
  settings: UserSettings!

  """Recommendations for current user."""
  recommendation: Recommendation!

  """Articles authored by current user."""
  articles(input: UserArticlesInput!): ArticleConnection!

  """Articles and moments authored by current user."""
  writings(input: WritingInput!): WritingConnection!

  """collections authored by current user."""
  collections(input: ConnectionArgs!): CollectionConnection!

  """user latest articles or collections"""
  latestWorks: [PinnableWork!]!

  """user pinned articles or collections"""
  pinnedWorks: [PinnableWork!]!

  """Tags by usage order of current user."""
  tags(input: ConnectionArgs!): TagConnection!

  """Drafts authored by current user."""
  drafts(input: ConnectionArgs!): DraftConnection!

  """Articles current user commented on"""
  commentedArticles(input: ConnectionArgs!): ArticleConnection!

  """Artilces current user bookmarked."""
  bookmarkedArticles(input: ConnectionArgs!): ArticleConnection!

  """Tags current user bookmarked."""
  bookmarkedTags(input: ConnectionArgs!): TagConnection!

  """Record of user activity, only accessable by current user."""
  activity: UserActivity!

  """Followers of this user."""
  followers(input: ConnectionArgs!): UserConnection!

  """Following contents of this user."""
  following: Following!

  """Whether current user is following viewer."""
  isFollower: Boolean!

  """Whether viewer is following current user."""
  isFollowee: Boolean!

  """Users that blocked by current user."""
  blockList(input: ConnectionArgs!): UserConnection!

  """Whether current user is blocking viewer."""
  isBlocking: Boolean!

  """Whether current user is blocked by viewer."""
  isBlocked: Boolean!

  """user data analytics, only accessable by current user."""
  analytics: UserAnalytics!

  """active applied campaigns"""
  campaigns(input: ConnectionArgs!): CampaignConnection!

  """Status of current user."""
  status: UserStatus
  oss: UserOSS!
  remark: String

  """User Wallet"""
  wallet: Wallet!

  """Payment pointer that resolves to Open Payments endpoints"""
  paymentPointer: String
}

type Member {
  """User who join to a Circle."""
  user: User!

  """Price chosen by user when joining a Circle."""
  price: Price!
}

type Price {
  """Unique ID."""
  id: ID!

  """Amount of Price."""
  amount: Float!

  """Current Price belongs to whcih Circle."""
  circle: Circle!

  """Currency of Price."""
  currency: TransactionCurrency!

  """State of Price."""
  state: PriceState!

  """Created time."""
  createdAt: DateTime! @deprecated(reason: "No longer in use")

  """Updated time."""
  updatedAt: DateTime! @deprecated(reason: "No longer in use")
}

type CircleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CircleEdge!]
}

type CircleEdge {
  cursor: String!
  node: Circle!
}

type MemberConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [MemberEdge!]
}

type MemberEdge {
  cursor: String!
  node: Member!
}

type SubscribeCircleResult {
  circle: Circle!

  """client secret for SetupIntent."""
  client_secret: String
}

type Invites {
  """Accepted invitation list"""
  accepted(input: ConnectionArgs!): InvitationConnection!

  """Pending invitation list"""
  pending(input: ConnectionArgs!): InvitationConnection!
}

type Invitation {
  """Unique ID."""
  id: ID!

  """Target person of this invitation."""
  invitee: Invitee!

  """Creator of this invitation."""
  inviter: User!

  """Invitation of current Circle."""
  circle: Circle!

  """Free period of this invitation."""
  freePeriod: Int!

  """Created time."""
  createdAt: DateTime!

  """Sent time."""
  sentAt: DateTime!

  """Accepted time."""
  acceptedAt: DateTime

  """Determine it's specific state."""
  state: InvitationState!
}

type Person {
  email: String!
}

union Invitee = Person | User

type InvitationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [InvitationEdge!]
}

type InvitationEdge {
  cursor: String!
  node: Invitation!
}

type CircleAnalytics {
  income: CircleIncomeAnalytics!
  subscriber: CircleSubscriberAnalytics!
  follower: CircleFollowerAnalytics!
  content: CircleContentAnalytics!
}

type CircleIncomeAnalytics {
  """income history of last 4 months"""
  history: [MonthlyDatum!]!

  """total income of all time"""
  total: Float!

  """income of this month"""
  thisMonth: Float!

  """income of next month"""
  nextMonth: Float!
}

type CircleSubscriberAnalytics {
  """subscriber count history of last 4 months"""
  subscriberHistory: [MonthlyDatum!]!

  """invitee count history of last 4 months"""
  inviteeHistory: [MonthlyDatum!]!

  """current subscriber count"""
  currentSubscriber: Int!

  """current invitee count"""
  currentInvitee: Int!
}

type CircleFollowerAnalytics {
  """subscriber count history of last 4 months"""
  history: [MonthlyDatum!]!

  """current follower count"""
  current: Int!

  """the percentage of follower count in reader count of circle articles"""
  followerPercentage: Float!
}

type CircleContentAnalytics {
  public: [CircleContentAnalyticsDatum!]
  paywall: [CircleContentAnalyticsDatum!]
}

type CircleContentAnalyticsDatum {
  node: Article!
  readCount: Int!
}

type MonthlyDatum {
  value: Float!
  date: DateTime!
}

input CircleInput {
  """Slugified name of a Circle."""
  name: String!
}

input PutCircleInput {
  """Unique ID."""
  id: ID

  """Unique ID of a Circle's avatar."""
  avatar: ID

  """Unique ID of a Circle's cover."""
  cover: ID

  """Slugified name of a Circle."""
  name: String

  """Human readable name of this Circle."""
  displayName: String

  """A short description of this Circle."""
  description: String

  """Circle's subscription fee."""
  amount: Float
}

input ToggleCircleMemberInput {
  """Unique ID."""
  id: ID!

  """Toggle value."""
  enabled: Boolean!

  """Unique ID of target user."""
  targetId: ID!
}

input SubscribeCircleInput {
  """Unique ID."""
  id: ID!

  """Wallet password."""
  password: String
}

input UnsubscribeCircleInput {
  """Unique ID."""
  id: ID!
}

input PutCircleArticlesInput {
  """Circle ID"""
  id: ID!

  """Article Ids"""
  articles: [ID!]

  """Action Type"""
  type: PutCircleArticlesType!

  """Access Type, `public` or `paywall` only."""
  accessType: ArticleAccessType!
  license: ArticleLicenseType
}

input InviteCircleInput {
  invitees: [InviteCircleInvitee!]!
  freePeriod: Int!
  circleId: ID!
}

input InviteCircleInvitee {
  id: ID
  email: String
}

enum CircleState {
  active
  archived
}

enum PriceState {
  active
  archived
}

enum PutCircleArticlesType {
  add
  remove
}

enum InvitationState {
  accepted
  pending
  transfer_succeeded
  transfer_failed
}

"""
This type contains content, author, descendant comments and related data of a comment.
"""
type Comment implements Node {
  """Unique ID of this comment."""
  id: ID!

  """State of this comment."""
  state: CommentState!
  type: CommentType!

  """Time of this comment was created."""
  createdAt: DateTime!

  """Content of this comment."""
  content: String

  """Author of this comment."""
  author: User!

  """This value determines this comment is pinned or not."""
  pinned: Boolean!

  """This value determines this comment is from article donator or not."""
  fromDonator: Boolean!

  """The counting number of upvotes."""
  upvotes: Int!

  """The counting number of downvotes."""
  downvotes: Int! @deprecated(reason: "No longer in use in querying")

  """The value determines current user's vote."""
  myVote: Vote

  """Descendant comments of this comment."""
  comments(input: CommentCommentsInput!): CommentConnection!

  """Parent comment of this comment."""
  parentComment: Comment

  """A Comment that this comment replied to."""
  replyTo: Comment
  remark: String

  """Current comment belongs to which Node."""
  node: Node!
}

type CommentConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CommentEdge!]
}

type CommentEdge {
  cursor: String!
  node: Comment!
}

input PutCommentInput {
  comment: CommentInput!
  id: ID
}

input CommentInput {
  content: String!
  replyTo: ID
  parentId: ID
  mentions: [ID!]
  type: CommentType!
  articleId: ID
  circleId: ID
  momentId: ID
}

input CommentCommentsInput {
  author: ID
  sort: CommentSort
  after: String
  first: Int
}

input CommentsInput {
  sort: CommentSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: Int
  filter: CommentsFilter
}

input FeaturedCommentsInput {
  sort: CommentSort
  after: String
  first: Int
}

input CommentsFilter {
  parentComment: ID
  state: CommentState
  author: ID
}

"""Enums for sorting comments by time."""
enum CommentSort {
  oldest
  newest
}

input PinCommentInput {
  id: ID!
}

input UnpinCommentInput {
  id: ID!
}

input DeleteCommentInput {
  id: ID!
}

input VoteCommentInput {
  vote: Vote!
  id: ID!
}

input UnvoteCommentInput {
  id: ID!
}

input UpdateCommentsStateInput {
  ids: [ID!]!
  state: CommentState!
}

"""Enums for vote types."""
enum Vote {
  up
  down
}

"""Enums for comment state."""
enum CommentState {
  active
  archived
  banned
  collapsed
}

enum CommentType {
  article
  circleDiscussion
  circleBroadcast
  moment
}

"""
This type contains content, collections, assets and related data of a draft.
"""
type Draft implements Node {
  """Unique ID of this draft."""
  id: ID!

  """Media hash, composed of cid encoding, of this draft."""
  mediaHash: String

  """Draft title."""
  title: String

  """Slugified draft title."""
  slug: String!

  """Summary of this draft."""
  summary: String

  """This value determines if the summary is customized or not."""
  summaryCustomized: Boolean!

  """Content (HTML) of this draft."""
  content: String

  """Time of this draft was created."""
  createdAt: DateTime!

  """Last time of this draft was upadted."""
  updatedAt: DateTime!

  """The counting number of words in this draft."""
  wordCount: Int!

  """Tags are attached to this draft."""
  tags: [String!]

  """Draft's cover link."""
  cover: String

  """State of draft during publihsing."""
  publishState: PublishState!

  """Scheduled publish date of the article."""
  publishAt: DateTime

  """List of assets are belonged to this draft."""
  assets: [Asset!]!

  """Published article"""
  article: Article

  """Connection articles of this draft."""
  connections(input: ConnectionArgs!): ArticleConnection!
  collection(input: ConnectionArgs!): ArticleConnection! @deprecated(reason: "Use connections instead")

  """Collections of this draft."""
  collections(input: ConnectionArgs!): CollectionConnection!

  """Access related fields on circle"""
  access: DraftAccess!

  """Whether content is marked as sensitive by author"""
  sensitiveByAuthor: Boolean!

  """License Type"""
  license: ArticleLicenseType!

  """Creator message asking for support"""
  requestForDonation: String

  """Creator message after support"""
  replyToDonator: String

  """Whether publish to ISCN"""
  iscnPublish: Boolean

  """Whether readers can comment"""
  canComment: Boolean!

  """Whether the first line of paragraph should be indented"""
  indentFirstLine: Boolean!

  """Associated campaigns"""
  campaigns: [ArticleCampaign!]!
}

type DraftConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DraftEdge!]
}

type DraftEdge {
  cursor: String!
  node: Draft!
}

type DraftAccess {
  type: ArticleAccessType!
  circle: Circle
}

input PutDraftInput {
  id: ID
  title: String
  summary: String
  content: String
  tags: [String!]
  cover: ID

  """Deprecated, use connections instead"""
  collection: [ID]
  connections: [ID!]

  """Add article to these collections when published"""
  collections: [ID!]
  circle: ID
  accessType: ArticleAccessType
  sensitive: Boolean
  license: ArticleLicenseType
  indentFirstLine: Boolean
  requestForDonation: String
  replyToDonator: String

  """Whether publish to ISCN"""
  iscnPublish: Boolean

  """Whether readers can comment"""
  canComment: Boolean

  """Which campaigns to attach"""
  campaigns: [ArticleCampaignInput!]

  """Last known update timestamp for version conflict detection"""
  lastUpdatedAt: DateTime
}

input DeleteDraftInput {
  id: ID!
}

"""Enums for publishing state."""
enum PublishState {
  unpublished
  pending
  error
  published
}

"""This interface contains common fields of a notice."""
interface Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!
}

type NoticeConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [NoticeEdge!]
}

type NoticeEdge {
  cursor: String!
  node: Notice!
}

type UserNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: UserNoticeType!
  target: User!
}

enum UserNoticeType {
  UserNewFollower
}

type ArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleNoticeType!
  target: Article!
  entities: [Node!]!
}

enum ArticleNoticeType {
  ArticlePublished
  ScheduledArticlePublished
  ArticleMentionedYou
  ArticleNewSubscriber
  ArticleNewAppreciation
  RevisedArticlePublished
  RevisedArticleNotPublished
  CircleNewArticle
  TopicChannelFeedbackAccepted
}

type ArticleArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: ArticleArticleNoticeType!
  target: Article!
  article: Article!
}

enum ArticleArticleNoticeType {
  ArticleNewCollected
}

type MomentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: MomentNoticeType!
  target: Moment!
}

enum MomentNoticeType {
  MomentMentionedYou
  MomentLiked
}

type CommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentNoticeType!
  target: Comment!
}

enum CommentNoticeType {
  CommentPinned
  CommentLiked
  CommentMentionedYou
  ArticleNewComment
  MomentNewComment
  SubscribedArticleNewComment
  CircleNewBroadcast
}

type CommentCommentNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CommentCommentNoticeType!
  target: Comment!
  comment: Comment!
}

enum CommentCommentNoticeType {
  CommentNewReply
}

type CampaignArticleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CampaignArticleNoticeType!
  target: Campaign!
  article: Article!
}

enum CampaignArticleNoticeType {
  CampaignArticleFeatured
}

type TransactionNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: TransactionNoticeType!
  target: Transaction!
}

enum TransactionNoticeType {
  PaymentReceivedDonation
  WithdrewLockedTokens
}

type CircleNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  type: CircleNoticeType!
  target: Circle!

  """Optional discussion/broadcast comments for bundled notices"""
  comments: [Comment!]

  """Optional discussion/broadcast replies for bundled notices"""
  replies: [Comment!]

  """Optional mention comments for bundled notices"""
  mentions: [Comment!]
}

enum CircleNoticeType {
  CircleInvitation
  CircleNewSubscriber
  CircleNewFollower
  CircleNewUnsubscriber
  CircleNewBroadcastComments
  CircleNewDiscussionComments
}

"""The notice type contains info about official announcement."""
type OfficialAnnouncementNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """The message content."""
  message: String!

  """The link to a specific page if provided."""
  link: String
}

scalar DateTime

scalar Upload

input KeywordsInput {
  keywords: [String!]
}

input KeywordInput {
  keyword: String!
}

interface Node {
  id: ID!
}

interface PinnableWork {
  id: ID!
  pinned: Boolean!
  title: String!
  cover: String
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

interface Connection {
  totalCount: Int!
  pageInfo: PageInfo!
}

type BlockedSearchKeyword {
  """Unique ID of bloked search keyword."""
  id: ID!

  """Types of this search keyword."""
  searchKey: String!

  """Time of this search keyword was created."""
  createdAt: DateTime!
}

"""This type contains system-wise info and settings."""
type Official {
  """Feature flag"""
  features: [Feature!]!

  """Announcements"""
  announcements(input: AnnouncementsInput!): [Announcement!]
}

type Feature {
  name: FeatureName!
  enabled: Boolean!
  value: Float
}

type Announcement {
  id: ID!
  title(input: TranslationArgs): String
  cover: String
  content(input: TranslationArgs): String
  link(input: TranslationArgs): String
  type: AnnouncementType!
  visible: Boolean!
  order: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  expiredAt: DateTime
  translations: [TranslatedAnnouncement!] @deprecated(reason: "Use title, content, link with TranslationArgs instead")
  channels: [AnnouncementChannel!]!
}

type AnnouncementChannel {
  channel: Channel!
  order: Int!
  visible: Boolean!
}

type TranslatedAnnouncement {
  language: UserLanguage!
  title: String
  cover: String
  content: String
  link: String
}

type OSS {
  users(input: ConnectionArgs!): UserConnection!
  comments(input: ConnectionArgs!): CommentConnection!
  articles(input: OSSArticlesInput!): ArticleConnection!
  tags(input: TagsInput!): TagConnection!
  oauthClients(input: ConnectionArgs!): OAuthClientConnection!
  skippedListItems(input: SkippedListItemsInput!): SkippedListItemsConnection!
  seedingUsers(input: ConnectionArgs!): UserConnection!
  badgedUsers(input: BadgedUsersInput!): UserConnection!
  restrictedUsers(input: ConnectionArgs!): UserConnection!
  reports(input: ConnectionArgs!): ReportConnection!
  icymiTopics(input: ConnectionArgs!): IcymiTopicConnection!
  topicChannelFeedbacks(input: TopicChannelFeedbacksInput!): TopicChannelFeedbackConnection!
}

"""This type contains type, link and related data of an asset."""
type Asset {
  """Unique ID of this Asset."""
  id: ID!

  """Types of this asset."""
  type: AssetType!

  """Link of this asset."""
  path: String!
  draft: Boolean
  uploadURL: String

  """Time of this asset was created."""
  createdAt: DateTime!
}

type SearchResultConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SearchResultEdge!]
}

type SearchResultEdge {
  cursor: String!
  node: Node!
}

input TagsInput {
  after: String
  first: Int
  sort: TagsSort
}

input SkippedListItemsInput {
  after: String
  first: Int
  type: SkippedListItemType
}

input BadgedUsersInput {
  after: String
  first: Int
  type: BadgeType
}

type SkippedListItemsConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [SkippedListItemEdge!]
}

type SkippedListItemEdge {
  cursor: String!
  node: SkippedListItem
}

type SkippedListItem {
  id: ID!
  uuid: ID!
  type: SkippedListItemType!
  value: String!
  archived: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserRestriction {
  type: UserRestrictionType!
  createdAt: DateTime!
}

type UserFeatureFlag {
  type: UserFeatureFlagType!
  createdAt: DateTime!
}

type Report implements Node {
  id: ID!
  reporter: User!
  target: Node!
  reason: ReportReason!
  createdAt: DateTime!
}

type ReportConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ReportEdge!]
}

type ReportEdge {
  cursor: String!
  node: Report!
}

input NodeInput {
  id: ID!
}

input NodesInput {
  ids: [ID!]!
}

input FrequentSearchInput {
  key: String
  first: Int
}

input SearchInput {
  """search keyword"""
  key: String!

  """types of search target"""
  type: SearchTypes!
  after: String
  first: Int

  """extra query filter for searching"""
  filter: SearchFilter

  """specific condition for rule data out"""
  exclude: SearchExclude

  """should include tags used by author"""
  includeAuthorTags: Boolean

  """whether this search operation should be recorded in search history"""
  record: Boolean
  oss: Boolean
  quicksearch: Boolean
}

input SearchFilter {
  authorId: ID
}

input SingleFileUploadInput {
  type: AssetType!
  file: Upload
  url: String
  draft: Boolean
  entityType: EntityType!
  entityId: ID
}

input DirectImageUploadInput {
  type: AssetType!
  mime: String
  url: String
  draft: Boolean
  entityType: EntityType!
  entityId: ID
}

input SetBoostInput {
  id: ID!
  boost: Float!
  type: BoostTypes!
}

input PutRemarkInput {
  id: ID!
  remark: String!
  type: RemarkTypes!
}

input PutSkippedListItemInput {
  id: ID
  type: SkippedListItemType
  value: String
  archived: Boolean
}

input LogRecordInput {
  type: LogRecordTypes!
}

input ConnectionArgs {
  after: String
  first: Int
  oss: Boolean
  filter: FilterInput
}

"""Common input to toggle single item for `toggleXXX` mutations"""
input ToggleItemInput {
  id: ID!
  enabled: Boolean
}

input SetFeatureInput {
  name: FeatureName!
  flag: FeatureFlag!
  value: Float
}

input ToggleSeedingUsersInput {
  ids: [ID!]
  enabled: Boolean!
}

input AnnouncementsInput {
  id: ID
  visible: Boolean
  channel: IdentityInput
}

input PutAnnouncementInput {
  id: ID
  title: [TranslationInput!]
  cover: String
  content: [TranslationInput!]
  link: [TranslationInput!]
  type: AnnouncementType
  expiredAt: DateTime
  visible: Boolean
  order: Int
  channels: [AnnouncementChannelInput!]
}

input AnnouncementChannelInput {
  channel: ID!
  visible: Boolean!
  order: Int!
}

input DeleteAnnouncementsInput {
  ids: [ID!]
}

input PutRestrictedUsersInput {
  ids: [ID!]!
  restrictions: [UserRestrictionType!]!
}

input PutUserFeatureFlagsInput {
  ids: [ID!]!
  flags: [UserFeatureFlagType!]!
}

input SubmitReportInput {
  targetId: ID!
  reason: ReportReason!
}

enum SearchTypes {
  Article
  User
  Tag
}

enum SearchAPIVersion {
  v20230601
  v20230301
}

enum BoostTypes {
  Article
  User
  Tag
  Campaign
}

enum RemarkTypes {
  Article
  User
  Tag
  Comment
  Report
  Feedback
}

enum LogRecordTypes {
  ReadFolloweeArticles
  ReadFollowingFeed
  ReadResponseInfoPopUp
}

"""Enums for sorting tags."""
enum TagsSort {
  newest
  oldest
  hottest
}

"""Enums for asset types."""
enum AssetType {
  avatar
  cover
  embed
  embedaudio
  profileCover
  oauthClientAvatar
  tagCover
  circleAvatar
  circleCover
  collectionCover
  announcementCover
  moment
  campaignCover
}

enum EntityType {
  article
  draft
  tag
  user
  circle
  announcement
  collection
  moment
  campaign
}

"""Enums for user roles."""
enum Role {
  vistor
  user
  admin
}

enum SkippedListItemType {
  agent_hash
  email
  domain
}

enum FeatureName {
  add_credit
  payment
  payout
  verify_appreciate
  fingerprint
  tag_adoption
  circle_management
  circle_interact
  spam_detection
  article_channel
}

enum FeatureFlag {
  on
  off
  admin
  seeding
}

enum SearchExclude {
  blocked
}

enum AnnouncementType {
  community
  product
  seminar
}

enum UserRestrictionType {
  articleHottest
  articleNewest
}

enum UserFeatureFlagType {
  bypassSpamDetection
  unlimitedArticleFetch
}

enum ReportReason {
  tort
  illegal_advertising
  discrimination_insult_hatred
  pornography_involving_minors
  other
}

type IcymiTopic implements Node {
  id: ID!
  title(input: TranslationArgs): String!
  articles: [Article!]!
  pinAmount: Int!
  note(input: TranslationArgs): String
  state: IcymiTopicState!
  publishedAt: DateTime
  archivedAt: DateTime
}

enum IcymiTopicState {
  published
  editing
  archived
}

type IcymiTopicConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [IcymiTopicEdge!]!
}

type IcymiTopicEdge {
  cursor: String!
  node: IcymiTopic!
}

type TopicChannelFeedbackConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopicChannelFeedbackEdge!]!
}

type TopicChannelFeedbackEdge {
  cursor: String!
  node: TopicChannelFeedback!
}

type TopicChannelFeedback {
  id: ID!
  type: TopicChannelFeedbackType!
  article: Article!

  """Which channels author want to be in, empty for no channels"""
  channels: [TopicChannel!]
  state: TopicChannelFeedbackState
  createdAt: DateTime!
}

input ReviewTopicChannelFeedbackInput {
  feedback: ID!
  action: TopicChannelFeedbackAction!
}

enum TopicChannelFeedbackType {
  positive
  negative
}

enum TopicChannelFeedbackAction {
  accept
  reject
}

enum TopicChannelFeedbackState {
  pending
  accepted
  rejected
  resolved
}

input TopicChannelFeedbacksInput {
  after: String
  first: Int!
  filter: TopicChannelFeedbacksFilterInput
}

input TopicChannelFeedbacksFilterInput {
  state: TopicChannelFeedbackState
  type: TopicChannelFeedbackType
  spam: Boolean
}

input PutIcymiTopicInput {
  id: ID
  title: [TranslationInput!]
  articles: [ID!]
  pinAmount: Int
  note: [TranslationInput!]
  state: IcymiTopicState
}

input SetSpamStatusInput {
  id: ID!
  isSpam: Boolean!
}

input SetAdStatusInput {
  id: ID!
  isAd: Boolean!
}

input OSSArticlesInput {
  after: String
  first: Int
  sort: ArticlesSort = newest
  filter: OSSArticlesFilterInput
}

input OSSArticlesFilterInput {
  isSpam: Boolean
  datetimeRange: DatetimeRangeInput
  searchKey: String
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

type Recommendation {
  """Activities based on user's following, sort by creation time."""
  following(input: RecommendationFollowingInput!): FollowingActivityConnection!

  """Global articles sort by publish time."""
  newest(input: RecommendationNewestInput!): ArticleConnection!

  """Global articles sort by latest activity time."""
  hottest(input: RecommendInput!): ArticleConnection!

  """'In case you missed it' recommendation."""
  icymi(input: ConnectionArgs!): ArticleConnection!

  """'In case you missed it' topic."""
  icymiTopic: IcymiTopic

  """Global tag list, sort by activities in recent 14 days."""
  tags(input: RecommendInput!): TagConnection!

  """Global user list, sort by activities in recent 6 month."""
  authors(input: RecommendInput!): UserConnection!
}

input RecommendInput {
  after: String
  first: Int
  oss: Boolean
  filter: RecommendFilterInput
  newAlgo: Boolean
}

input RecommendFilterInput {
  channel: IdentityInput

  """index of list, min: 0, max: 49"""
  random: Int

  """filter out followed users"""
  followed: Boolean
}

input IdentityInput {
  id: ID
  shortHash: String
}

input FilterInput {
  """Used in User Articles filter, by tags or by time range, or both"""
  tagIds: [ID!]
  inRangeStart: DateTime
  inRangeEnd: DateTime
}

type UserInfo {
  """Timestamp of registration."""
  createdAt: DateTime

  """Is user name editable."""
  userNameEditable: Boolean!

  """User desciption."""
  description: String

  """
  the ipnsKey (`ipfs.io/ipns/<ipnsKey>/...`) for feed.json / rss.xml / index
  """
  ipnsKey: String

  """User email."""
  email: String

  """Weather user email is verified."""
  emailVerified: Boolean!

  """User connected social accounts."""
  socialAccounts: [SocialAccount!]!

  """User badges."""
  badges: [Badge!]

  """Timestamp of user agreement."""
  agreeOn: DateTime

  """Cover of profile page."""
  profileCover: String

  """Type of group."""
  group: UserGroup!

  """Login address"""
  ethAddress: String
  isWalletAuth: Boolean!

  """Connected wallet."""
  cryptoWallet: CryptoWallet

  """
  saved tags for showing on profile page, API allows up to 100, front-end lock'ed at lower limit
  """
  featuredTags: [Tag!]
}

type UserSettings {
  """User language setting."""
  language: UserLanguage!

  """User currency preference."""
  currency: QuoteCurrency!

  """Notification settings."""
  notification: NotificationSetting
}

type UserActivity {
  """User reading history."""
  history(input: ConnectionArgs!): ReadHistoryConnection!

  """User search history."""
  recentSearches(input: ConnectionArgs!): RecentSearchConnection!

  """Appreciations current user gave."""
  appreciationsSent(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user gave."""
  appreciationsSentTotal: Int!

  """Appreciations current user received."""
  appreciationsReceived(input: ConnectionArgs!): AppreciationConnection!

  """Total number of appreciation current user received."""
  appreciationsReceivedTotal: Int!
}

type UserAnalytics {
  """Top donators of current user."""
  topDonators(input: TopDonatorInput!): TopDonatorConnection!
}

input TopDonatorInput {
  after: String
  first: Int
  filter: TopDonatorFilter
}

input TopDonatorFilter {
  inRangeStart: DateTime
  inRangeEnd: DateTime
}

type TopDonatorConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopDonatorEdge!]
}

union Donator = User | CryptoWallet

type TopDonatorEdge {
  cursor: String!
  node: Donator!
  donationCount: Int!
}

type UserStatus {
  """User state."""
  state: UserState!

  """User role and access level."""
  role: UserRole!

  """Number of articles published by user"""
  articleCount: Int!

  """Number of moments posted by user"""
  momentCount: Int!

  """Number of comments posted by user."""
  commentCount: Int!

  """Number of unread notices."""
  unreadNoticeCount: Int!

  """Whether there are unread activities from following."""
  unreadFollowing: Boolean!

  """Number of total written words."""
  totalWordCount: Int!

  """
  Number of referred user registration count (in Digital Nomad Campaign).
  """
  totalReferredCount: Int!

  """Weather login password is set for email login."""
  hasEmailLoginPassword: Boolean!

  """
  Number of chances for the user to change email in a nature day. Reset in UTC+8 0:00
  """
  changeEmailTimesLeft: Int!

  """Whether user already set payment password."""
  hasPaymentPassword: Boolean!

  """Number of articles donated by user"""
  donatedArticleCount: Int!

  """Number of times of donations received by user"""
  receivedDonationCount: Int!
}

type Liker {
  """Liker ID of LikeCoin"""
  likerId: String

  """Whether liker is a civic liker"""
  civicLiker: Boolean!

  """Total LIKE left in wallet."""
  total: Float!
}

type UserOSS {
  boost: Float!
  score: Float!
  restrictions: [UserRestriction!]!
  featureFlags: [UserFeatureFlag!]!
}

type Appreciation {
  amount: Int!
  purpose: AppreciationPurpose!
  content: String!

  """Timestamp of appreciation."""
  createdAt: DateTime!

  """Recipient of appreciation."""
  recipient: User!

  """Sender of appreciation."""
  sender: User

  """Object that appreciation is meant for."""
  target: Article
}

type NotificationSetting {
  email: Boolean!
  mention: Boolean!
  newComment: Boolean!
  newLike: Boolean!
  userNewFollower: Boolean!
  articleNewComment: Boolean!
  articleNewAppreciation: Boolean!
  articleNewSubscription: Boolean!
  articleNewCollected: Boolean!

  """for circle owners"""
  circleNewSubscriber: Boolean!
  circleNewFollower: Boolean!
  circleNewUnsubscriber: Boolean!
  circleMemberNewBroadcastReply: Boolean!
  circleMemberNewDiscussion: Boolean!
  circleMemberNewDiscussionReply: Boolean!

  """for circle members & followers"""
  inCircleNewArticle: Boolean!
  inCircleNewBroadcast: Boolean!
  inCircleNewBroadcastReply: Boolean!
  inCircleNewDiscussion: Boolean!
  inCircleNewDiscussionReply: Boolean!
}

type ReadHistory {
  article: Article!
  readAt: DateTime!
}

type Badge {
  type: BadgeType!
}

type AuthResult {
  auth: Boolean!
  token: String
  type: AuthResultType!
  user: User
}

enum AuthResultType {
  Login
  Signup
  LinkAccount
}

type SigningMessageResult {
  nonce: String!
  purpose: SigningMessagePurpose!
  signingMessage: String!
  createdAt: DateTime!
  expiredAt: DateTime!
}

type UserConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [UserEdge!]
}

type UserEdge {
  cursor: String!
  node: User!
}

type ReadHistoryConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ReadHistoryEdge!]
}

type ReadHistoryEdge {
  cursor: String!
  node: ReadHistory!
}

type RecentSearchConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [RecentSearchEdge!]
}

type RecentSearchEdge {
  cursor: String!
  node: String!
}

type AppreciationConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [AppreciationEdge!]
}

type AppreciationEdge {
  cursor: String!
  node: Appreciation!
}

type FollowingActivityConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [FollowingActivityEdge!]
}

type FollowingActivityEdge {
  cursor: String!
  node: FollowingActivity!
}

union FollowingActivity = UserPublishArticleActivity | UserAddArticleTagActivity | UserPostMomentActivity | UserBroadcastCircleActivity | UserCreateCircleActivity | UserRecommendationActivity | ArticleRecommendationActivity | CircleRecommendationActivity

type UserPublishArticleActivity {
  actor: User!
  createdAt: DateTime!

  """Article published by actor"""
  node: Article!
}

type UserAddArticleTagActivity {
  actor: User!
  createdAt: DateTime!

  """Article added to tag"""
  node: Article!

  """Tag added by article"""
  target: Tag!
}

type UserPostMomentActivity {
  actor: User!
  createdAt: DateTime!

  """Moment posted by actor"""
  node: Moment!

  """Another 3 moments posted by actor"""
  more: [Moment!]!
}

type UserBroadcastCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Comment broadcast by actor"""
  node: Comment!

  """Circle that comment belongs to"""
  target: Circle!
}

type UserCreateCircleActivity {
  actor: User!
  createdAt: DateTime!

  """Circle created by actor"""
  node: Circle!
}

type UserRecommendationActivity {
  """The source type of recommendation"""
  source: UserRecommendationActivitySource

  """Recommended users"""
  nodes: [User!]
}

enum UserRecommendationActivitySource {
  UserFollowing
}

type ArticleRecommendationActivity {
  """The source type of recommendation"""
  source: ArticleRecommendationActivitySource

  """Recommended articles"""
  nodes: [Article!]
}

enum ArticleRecommendationActivitySource {
  UserDonation
  ReadArticlesTags
}

type CircleRecommendationActivity {
  """The source type of recommendation"""
  source: CircleRecommendationActivitySource

  """Recommended circles"""
  nodes: [Circle!]
}

enum CircleRecommendationActivitySource {
  UserSubscription
}

type Following {
  circles(input: ConnectionArgs!): CircleConnection!
  users(input: ConnectionArgs!): UserConnection!
}

type CryptoWallet {
  id: ID!
  address: String!

  """ does this address own any Travelogger NFTs? this value is cached at most 1day, and refreshed at next `nfts` query 
  """
  hasNFTs: Boolean!

  """NFT assets owned by this wallet address"""
  nfts: [NFTAsset!]
}

""" NFT Asset """
type NFTAsset {
  id: ID!
  name: String!
  description: String
  imageUrl: String!
  imagePreviewUrl: String

  """imageOriginalUrl: String!"""
  contractAddress: String!
  collectionName: String!
}

input UserInput {
  userName: String

  """used for case insensitive username search """
  userNameCaseIgnore: Boolean = false
  ethAddress: String
}

input SendVerificationCodeInput {
  email: String!
  type: VerificationCodeType!
  token: String

  """
  Redirect URL embedded in the verification email,
  use code instead if not provided.
  """
  redirectUrl: String

  """email content language"""
  language: UserLanguage
}

input ConfirmVerificationCodeInput {
  email: String!
  type: VerificationCodeType!
  code: String!
}

input ResetPasswordInput {
  password: String!
  codeId: ID!
  type: ResetPasswordType
}

input VerifyEmailInput {
  email: String!
  code: String!
}

input SetCurrencyInput {
  currency: QuoteCurrency
}

input GenerateSigningMessageInput {
  address: String!
  purpose: SigningMessagePurpose
}

input WalletLoginInput {
  ethAddress: String!

  """the message being sign'ed, including nonce"""
  signedMessage: String!

  """sign'ed by wallet"""
  signature: String!

  """nonce from generateSigningMessage"""
  nonce: String!

  """used in register"""
  language: UserLanguage
  referralCode: String
}

input ResetLikerIdInput {
  id: ID!
}

input UpdateNotificationSettingInput {
  type: NotificationSettingType!
  enabled: Boolean!
}

input UpdateUserInfoInput {
  displayName: String
  avatar: ID
  description: String
  language: UserLanguage
  agreeOn: Boolean
  profileCover: ID
  paymentPassword: String
  paymentPointer: String
  referralCode: String
}

input UpdateUserStateInput {
  id: ID
  emails: [String!]
  state: UserState!
  banDays: Int
  password: String
}

input UpdateUserRoleInput {
  id: ID!
  role: UserRole!
}

input UpdateUserExtraInput {
  id: ID!
  referralCode: String
}

input RefreshIPNSFeedInput {
  userName: String!

  """refresh how many recent articles, default to 50"""
  numArticles: Int = 50
}

input ToggleUsersBadgeInput {
  ids: [ID!]!
  type: BadgeType!
  enabled: Boolean!
}

input UnbindLikerIdInput {
  id: ID!
  likerId: String!
}

input ClearReadHistoryInput {
  id: ID
}

input MigrationInput {
  type: MigrationType
  files: [Upload]!
}

input ClaimLogbooksInput {
  ethAddress: String!

  """the message being sign'ed, including nonce"""
  signedMessage: String!

  """sign'ed by wallet"""
  signature: String!

  """nonce from generateSigningMessage"""
  nonce: String!
}

input FeaturedTagsInput {
  """ tagIds """
  ids: [ID!]!
}

type ClaimLogbooksResult {
  ids: [ID!]
  txHash: String!
}

enum BadgeType {
  seed
  golden_motor
  architect
  grand_slam
  nomad1
  nomad2
  nomad3
  nomad4
}

enum VerificationCodeType {
  register
  email_verify
  email_otp
  payment_password_reset
}

enum ResetPasswordType {
  account
  payment
}

enum UserInfoFields {
  displayName
  avatar
  description
  email
  agreeOn
}

enum UserLanguage {
  en
  zh_hans
  zh_hant
}

enum NotificationSettingType {
  email
  mention
  newComment
  newLike
  userNewFollower
  articleNewComment
  articleNewAppreciation
  articleNewSubscription
  articleNewCollected

  """for circle owners"""
  circleNewSubscriber
  circleNewFollower
  circleNewUnsubscriber
  circleNewDiscussion
  circleMemberBroadcast
  circleMemberNewDiscussion
  circleMemberNewDiscussionReply
  circleMemberNewBroadcastReply

  """for circle members"""
  inCircleNewArticle
  inCircleNewBroadcast
  inCircleNewBroadcastReply
  inCircleNewDiscussion
  inCircleNewDiscussionReply
}

enum UserState {
  active
  banned
  archived
  frozen
}

enum UserRole {
  user
  admin
}

enum UserGroup {
  a
  b
}

enum AppreciationPurpose {
  appreciate
  appreciateComment
  appreciateSubsidy
  invitationAccepted
  joinByInvitation
  joinByTask
  firstPost
  systemSubsidy
}

enum MigrationType {
  medium
}

enum AuthorsType {
  active
  appreciated
  default
  trendy
}

enum CryptoWalletSignaturePurpose {
  airdrop
  connect
  signup
  login
}

enum SigningMessagePurpose {
  airdrop
  connect
  signup
  login
  claimLogbook
}

enum QuoteCurrency {
  TWD
  HKD
  USD
}

type SocialAccount {
  type: SocialAccountType!
  userName: String
  email: String
}

enum SocialAccountType {
  Google
  Twitter
  Facebook
}

input EmailLoginInput {
  email: String!
  passwordOrCode: String!

  """used in register"""
  language: UserLanguage
  referralCode: String
}

input SocialLoginInput {
  type: SocialAccountType!
  authorizationCode: String

  """OAuth2 PKCE code_verifier for Facebook and Twitter"""
  codeVerifier: String

  """OIDC nonce for Google"""
  nonce: String

  """oauth token/verifier in OAuth1.0a for Twitter"""
  oauth1Credential: Oauth1CredentialInput

  """used in register"""
  language: UserLanguage
  referralCode: String
}

input Oauth1CredentialInput {
  oauthToken: String!
  oauthVerifier: String!
}

input SetUserNameInput {
  userName: String!
}

input SetEmailInput {
  email: String!
}

input SetPasswordInput {
  password: String!
}

input RemoveSocialLoginInput {
  type: SocialAccountType!
}

input UserArticlesInput {
  after: String
  first: Int
  sort: UserArticlesSort = newest
  filter: UserArticlesFilter
}

enum UserArticlesSort {
  newest
  mostReaders
  mostAppreciations
  mostComments
  mostDonations
}

input UserArticlesFilter {
  state: ArticleState = active
}

input WritingInput {
  after: String
  first: Int
}

union Writing = Article | Moment

type WritingConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [WritingEdge!]
}

type WritingEdge {
  cursor: String!
  node: Writing!
}

input RecommendationFollowingInput {
  first: Int
  after: String
  filter: RecommendationFollowingFilterInput
}

input RecommendationNewestInput {
  after: String
  first: Int
  oss: Boolean
  filter: FilterInput
  excludeChannelArticles: Boolean
}

input RecommendationFollowingFilterInput {
  type: RecommendationFollowingFilterType
}

enum RecommendationFollowingFilterType {
  article
}

union Response = Article | Comment

type ResponseConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ResponseEdge!]
}

type ResponseEdge {
  cursor: String!
  node: Response!
}

input ResponsesInput {
  sort: ResponseSort
  after: String
  before: String
  includeAfter: Boolean
  includeBefore: Boolean
  first: Int
  articleOnly: Boolean
}

"""Enums for sorting responses."""
enum ResponseSort {
  oldest
  newest
}

input ExchangeRatesInput {
  from: TransactionCurrency
  to: QuoteCurrency
}

type ExchangeRate {
  from: TransactionCurrency!
  to: QuoteCurrency!
  rate: Float!

  """Last updated time from currency convertor APIs"""
  updatedAt: DateTime!
}

union TransactionTarget = Article | Circle | Transaction

type Wallet {
  balance: Balance!
  transactions(input: TransactionsArgs!): TransactionConnection!

  """Account of Stripe Connect to manage payout"""
  stripeAccount: StripeAccount

  """
  URL of Stripe Dashboard to manage subscription invoice and payment method
  """
  customerPortal: String

  """The last four digits of the card."""
  cardLast4: String
}

type Balance {
  HKD: Float!
}

type Transaction {
  id: ID!
  state: TransactionState!
  purpose: TransactionPurpose!
  amount: Float!
  fee: Float!
  currency: TransactionCurrency!

  """Timestamp of transaction."""
  createdAt: DateTime!

  """Recipient of transaction."""
  recipient: User

  """Sender of transaction."""
  sender: User

  """Related target article or transaction."""
  target: TransactionTarget

  """Message for end user, including reason of failure."""
  message: String

  """blockchain transaction info of ERC20/native token payment transaction"""
  blockchainTx: BlockchainTransaction
}

type TransactionConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TransactionEdge!]
}

type TransactionEdge {
  cursor: String!
  node: Transaction!
}

input TransactionsArgs {
  after: String
  first: Int

  """deprecated, use TransactionsFilter.id instead."""
  id: ID

  """deprecated, use TransactionsFilter.states instead."""
  states: [TransactionState!]
  filter: TransactionsFilter
}

input TransactionsFilter {
  id: ID
  states: [TransactionState!]
  currency: TransactionCurrency
  purpose: TransactionPurpose
}

enum TransactionState {
  pending
  succeeded
  failed
  canceled
}

enum TransactionPurpose {
  donation
  addCredit
  refund
  payout
  subscriptionSplit
  dispute
  payoutReversal
  curationVaultWithdrawal
}

enum TransactionCurrency {
  HKD
  LIKE
  USDT
}

type AddCreditResult {
  transaction: Transaction!

  """The client secret of this PaymentIntent."""
  client_secret: String!
}

type PayToResult {
  transaction: Transaction!

  """Only available when paying with LIKE."""
  redirectUrl: String
}

input AddCreditInput {
  amount: Float!
}

input PayToInput {
  amount: Float!
  currency: TransactionCurrency!
  purpose: TransactionPurpose!
  recipientId: ID!
  targetId: ID

  """for HKD payment"""
  password: String

  """for ERC20/native token payment"""
  chain: Chain
  txHash: String
  id: ID
}

input PayoutInput {
  amount: Float!
  password: String!
}

input ConnectStripeAccountInput {
  country: StripeAccountCountry!
}

type StripeAccount {
  id: ID!
  loginUrl: String!
}

type ConnectStripeAccountResult {
  redirectUrl: String!
}

type WithdrawLockedTokensResult {
  transaction: Transaction!
}

enum StripeAccountCountry {
  Australia
  Austria
  Belgium
  Bulgaria
  Canada
  Cyprus
  Denmark
  Estonia
  Finland
  France
  Germany
  Greece
  HongKong
  Ireland
  Italy
  Latvia
  Lithuania
  Luxembourg
  Malta
  Netherlands
  NewZealand
  Norway
  Poland
  Portugal
  Romania
  Singapore
  Slovakia
  Slovenia
  Spain
  Sweden
  UnitedKingdom
  UnitedStates
}

enum Chain {
  Polygon
  Optimism
}

type BlockchainTransaction {
  chain: Chain!
  txHash: String!
}

type OAuthClient {
  """Unique Client ID of this OAuth Client."""
  id: ID!

  """App name"""
  name: String!

  """App Description"""
  description: String

  """URL for oauth client's official website"""
  website: String

  """Scopes"""
  scope: [String!]

  """URL for oauth client's avatar."""
  avatar: String

  """Client secret"""
  secret: String!

  """Redirect URIs"""
  redirectURIs: [String!]

  """Grant Types"""
  grantTypes: [GrantType!]

  """Linked Developer Account"""
  user: User

  """Creation Date"""
  createdAt: DateTime!
}

type OAuthClientConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [OAuthClientEdge!]
}

type OAuthClientEdge {
  cursor: String!
  node: OAuthClient!
}

input OAuthClientInput {
  id: ID!
}

input PutOAuthClientInput {
  id: ID
  name: String
  description: String
  website: String
  scope: [String!]
  avatar: ID
  secret: String
  redirectURIs: [String!]
  grantTypes: [GrantType!]
  user: ID
}

enum GrantType {
  authorization_code
  refresh_token
}

type Collection implements Node & PinnableWork {
  id: ID!
  title: String!
  cover: String
  description: String
  author: User!
  articles(input: CollectionArticlesInput!): ArticleConnection!
  pinned: Boolean!
  updatedAt: DateTime!
  likeCount: Int!

  """whether current user has liked it"""
  liked: Boolean!

  """Check if the collection contains the article"""
  contains(input: NodeInput!): Boolean!
}

type CollectionEdge {
  cursor: String!
  node: Collection!
}

type CollectionConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CollectionEdge!]
}

type CollectionNotice implements Notice {
  """Unique ID of this notice."""
  id: ID!

  """The value determines if the notice is unread or not."""
  unread: Boolean!

  """Time of this notice was created."""
  createdAt: DateTime!

  """List of notice actors."""
  actors: [User!]
  target: Collection!
}

input CollectionArticlesInput {
  after: String
  first: Int
  before: String
  last: Int
  includeAfter: Boolean! = false
  includeBefore: Boolean! = false
  reversed: Boolean! = true
}

input PutCollectionInput {
  id: ID
  title: String
  cover: ID
  description: String
  pinned: Boolean
}

input DeleteCollectionsInput {
  ids: [ID!]!
}

input AddCollectionsArticlesInput {
  collections: [ID!]!
  articles: [ID!]!
}

input DeleteCollectionArticlesInput {
  collection: ID!
  articles: [ID!]!
}

input ReorderMoveInput {
  item: ID!

  """
  The new position move to. To move item to the beginning of the list, set to 0. To the end of the list, set to the length of the list - 1.
  """
  newPosition: Int!
}

input ReorderCollectionArticlesInput {
  collection: ID!
  moves: [ReorderMoveInput!]!
}

input LikeCollectionInput {
  id: ID!
}

input UnlikeCollectionInput {
  id: ID!
}

input MomentInput {
  shortHash: String!
}

input PutMomentInput {
  content: String!
  assets: [ID!]!
}

input DeleteMomentInput {
  id: ID!
}

input LikeMomentInput {
  id: ID!
}

input UnlikeMomentInput {
  id: ID!
}

type Moment implements Node {
  id: ID!
  shortHash: String!
  content: String
  assets: [Asset!]!
  author: User!
  state: MomentState!
  commentCount: Int!
  commentedFollowees: [User!]!
  comments(input: CommentsInput!): CommentConnection!
  likeCount: Int!

  """whether current user has liked it"""
  liked: Boolean!
  createdAt: DateTime!
}

enum MomentState {
  active
  archived
}

interface Channel {
  id: ID!
  shortHash: String!
  navbarTitle(input: TranslationArgs): String!
}

type TopicChannel implements Channel {
  id: ID!
  shortHash: String!
  navbarTitle(input: TranslationArgs): String!
  name(input: TranslationArgs): String!
  note(input: TranslationArgs): String
  providerId: String
  enabled: Boolean!
  articles(input: ChannelArticlesInput!): ChannelArticleConnection!
}

type CurationChannel implements Channel {
  id: ID!
  shortHash: String!
  navbarTitle(input: TranslationArgs): String!
  name(input: TranslationArgs): String!
  note(input: TranslationArgs): String
  pinAmount: Int!
  color: Color!
  showRecommendation: Boolean!

  """both activePeriod and state determine if the channel is active"""
  activePeriod: DatetimeRange!
  state: CurationChannelState!
  articles(input: ChannelArticlesInput!): ChannelArticleConnection!
}

input ChannelArticlesInput {
  after: String
  first: Int
  sort: ArticlesSort
  filter: ChannelArticlesFilter
  oss: Boolean = false
}

input ChannelArticlesFilter {
  datetimeRange: DatetimeRangeInput
  searchKey: String
}

input ChannelInput {
  shortHash: String!
}

input ChannelsInput {
  """return all channels if true, only active channels by default"""
  oss: Boolean = false
}

type ChannelArticleConnection implements Connection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [ChannelArticleEdge!]
}

type ChannelArticleEdge {
  cursor: String!
  node: Article!
  pinned: Boolean!
}

input AddCurationChannelArticlesInput {
  channel: ID!
  articles: [ID!]!
}

input DeleteCurationChannelArticlesInput {
  channel: ID!
  articles: [ID!]!
}

input TogglePinChannelArticlesInput {
  """id of TopicChannel or CurationChannel"""
  channels: [ID!]!
  articles: [ID!]!
  pinned: Boolean!
}

input PutTopicChannelInput {
  id: ID
  providerId: String
  name: [TranslationInput!]
  note: [TranslationInput!]
  navbarTitle: [TranslationInput!]
  enabled: Boolean
  subChannels: [ID!]
}

input PutCurationChannelInput {
  id: ID
  name: [TranslationInput!]
  note: [TranslationInput!]
  navbarTitle: [TranslationInput!]
  pinAmount: Int
  color: Color
  activePeriod: DatetimeRangeInput
  state: CurationChannelState
  showRecommendation: Boolean
}

input SetArticleTopicChannelsInput {
  id: ID!
  channels: [ID!]!
}

input ReorderChannelsInput {
  """ids of TopicChannels, CurationChannels, and WritingChallenges"""
  ids: [ID!]!
}

input ClassifyArticlesChannelsInput {
  ids: [ID!]!
}

enum CurationChannelState {
  editing
  published
  archived
}

enum Color {
  gray
  brown
  orange
  yellow
  green
  purple
  pink
  red
}