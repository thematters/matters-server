input AddDraftTagInput {
  id: ID
  tag: String
}

input AddOAuthInput {
  name: String!
  id: String!
  type: OAuthType
}

input AppreciateArticleInput {
  id: ID!
  amount: Int
}

input ArchiveArticleInput {
  id: ID!
}

type Article implements Node {
  id: ID!
  createdAt: DateTime!
  public: Boolean!
  author: User!
  title: String!

  """url for cover"""
  cover: URL!
  summary: String!
  tags: [Tag!]
  wordCount: Int
  hash: String
  content: String!
  gatewayUrls: [URL]
  upstream: Article
  downstreams: [Article]
  relatedArticles(input: ListInput!): [Article]!

  """MAT recieved for this article"""
  MAT: Int!
  commentCount: Int!

  """Current user has subscribed"""
  subscribed: Boolean!
  pinnedComments: [Comment]
  comments(input: CommentsInput!): [Comment]
  subscribers(input: ListInput!): [User]
  appreciators(input: ListInput!): [User]
  appreciatorCount: Int!
  hasAppreciate: Boolean!
  publishState: PublishState!
}

type ArticleArchivedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Article!
  reason: ArticleArchivedReason
}

enum ArticleArchivedReason {
  violation
}

type ArticleNewAppreciationNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Article!
  MAT: Int!
}

type ArticleNewCommentNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Article!
}

type ArticleNewDownstreamNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  downstream: Article!
  target: Article!
}

type ArticleNewSubscriberNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Article!
}

type ArticlePublishedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Article!
}

type ArticleReportedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Article!
  reason: ArticleReportedReason
}

enum ArticleReportedReason {
  violation
}

type AudioDraft {
  id: ID!
  authorId: Int!
  title: String
  path: String!
  length: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ClearReadHistoryInput {
  uuid: UUID
}

type Comment implements Node {
  id: ID!

  """Original article of this comment"""
  article: Article!

  """content"""
  content: String

  """Creation time of this comment"""
  createdAt: DateTime!
  author: User!
  achieved: Boolean!
  upvotes: Int!
  downvotes: Int!
  quotation: String
  myVote: Vote
  mentions: [User]
  comments: [Comment]
  parentComment: Comment
}

type CommentArchivedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Comment!
  reason: CommentArchivedReason
}

enum CommentArchivedReason {
  violation
}

input CommentInput {
  content: String!
  quotation: String
  articleId: ID!
  parentId: ID
  mentions: [ID]
}

type CommentMentionedYouNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Comment!
}

type CommentNewReplyNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Comment!
}

type CommentNewUpvoteNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Comment!
}

type CommentPinnedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Comment!
}

type CommentReportedNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  target: Comment!
  reason: CommentReportedReason
}

enum CommentReportedReason {
  violation
}

input CommentsInput {
  offset: Int
  limit: Int
  author: ID
  quoted: Boolean
  sort: CommentSort
}

enum CommentSort {
  oldest
  newest
}

input CreateDraftInput {
  upstreamid: ID
  title: String
  content: String
  tags: [String]
  cover: URL
}

input CreateOrEditAudioDraftInput {
  path: String!
  title: String
  id: ID
}

input CreateOrEditCommentInput {
  comment: CommentInput!
  id: ID
}

scalar Date

scalar DateTime

input DeleteCommentInput {
  id: ID!
}

input DeleteDraftInput {
  id: ID
}

input DeleteDraftTagInput {
  id: ID
  tag: String
}

type Draft implements Node {
  id: ID!
  upstream: Article
  title: String
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [String]
  cover: URL
  abstract: String
}

enum DraftField {
  upstream
  title
  cover
  content
}

input EditDraftInput {
  id: ID
  field: DraftField
  value: String
}

scalar Email

union Entity = User | Article | Tag

type File {
  filename: String!
  mimetype: String!
  encoding: String!
  path: String!
}

input FollowUserInput {
  id: ID!
}

input ImportArticlesInput {
  platform: String
  token: String
}

scalar JSON

input ListInput {
  offset: Int
  limit: Int
}

type LoginResult {
  auth: Boolean!
  token: String
}

type Mutation {
  _: Boolean
  publishArticle(input: PublishArticleInput): Article!
  archiveArticle(input: ArchiveArticleInput): Article!
  subscribeArticle(input: SubscribeArticleInput): Boolean
  unsubscribeArticle(input: UnsubscribeArticleInput): Boolean
  reportArticle(input: ReportArticleInput): Boolean
  appreciateArticle(input: AppreciateArticleInput): Int!
  readArticle(input: ReadArticleInput): Boolean
  recallPublication(input: RecallPublicationInput): Draft!
  createOrEditComment(input: CreateOrEditCommentInput): Comment
  pinComment(input: PinCommentInput): Comment
  deleteComment(input: DeleteCommentInput): Boolean
  createOrEditAudioDraft(input: CreateOrEditAudioDraftInput): AudioDraft
  createDraft(input: CreateDraftInput): Draft
  deleteDraft(input: DeleteDraftInput): Boolean
  editDraft(input: EditDraftInput): Draft
  addDraftTag(input: AddDraftTagInput): Draft
  deleteDraftTag(input: DeleteDraftTagInput): Boolean
  singleFileDelete(input: SingleFileDeleteInput): Boolean
  singleFileUpload(input: SingleFileUploadInput): File!
  markAllNoticesAsRead: Boolean
  sendVerificationEmail(input: SendVerificationEmailInput): Boolean
  sendPasswordResetEmail(input: SendVerificationEmailInput): Boolean
  sendEmailResetEmail(input: SendEmailResetEmailInput): Boolean
  verifyEmailResetCode(input: VerifyEmailResetCodeInput): Boolean
  resetPassword(input: ResetPasswordInput): Boolean
  userRegister(input: UserRegisterInput): User
  userLogin(input: UserLoginInput): LoginResult!
  addOAuth(input: AddOAuthInput): Boolean
  updateUserInfo(input: UpdateUserInfoInput): User!
  followUser(input: FollowUserInput): Boolean
  unfollowUser(input: UnfollowUserInput): Boolean
  importArticles(input: ImportArticlesInput): [Article]
  updateNotificationSetting(input: UpdateNotificationSettingInput): NotificationSetting
  clearReadHistory(input: ClearReadHistoryInput): Boolean
  clearSearchHistory: Boolean
}

interface Node {
  id: ID!
}

input NodeEditedInput {
  id: ID!
}

input NodeInput {
  id: ID!
}

interface Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
}

type NotificationSetting {
  enable: Boolean!
  mention: Boolean!
  follow: Boolean!
  comment: Boolean!
  appreciation: Boolean!
  articleSubscription: Boolean!
  commentSubscribed: Boolean!
  downstream: Boolean!
  commentPinned: Boolean!
  commentVoted: Boolean!
  walletUpdate: Boolean!
  officialNotice: Boolean!
  reportFeedback: Boolean!
}

enum OAuthType {
  facebook
  wechat
  google
}

type Official {
  reportCategory: [String]!
}

type OfficialAnnouncementNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  message: String!
  link: URL
}

input PinCommentInput {
  id: ID!
}

input PublishArticleInput {
  """publish with draft id"""
  id: ID!
}

enum PublishState {
  archived
  pending
  error
  published
}

"""
The dummy queries and mutations are necessary because
graphql-js cannot have empty root types and we only extend
these types later on
Ref: apollographql/graphql-tools#293
"""
type Query {
  _: Boolean
  node(input: NodeInput!): Node
  frequentSearch(key: String): [String]
  search(key: String): [SearchResult]
  official: Official!
  viewer: User
}

input ReadArticleInput {
  id: ID!
}

input RecallPublicationInput {
  id: ID!
}

type Recommendation {
  hottest(input: ListInput!): [Article]!

  """In case you missed it"""
  icymi(input: ListInput!): [Article]!
  tags(input: ListInput!): [Tag]!
  topics(input: ListInput!): [Article]!
  authors(input: ListInput!): [User]!
}

input ReportArticleInput {
  id: ID!
  category: String
  description: String
}

input ResetPasswordInput {
  password: String!
  code: String
}

input SearchInput {
  key: String!
  type: SearchTypes
  offset: Int
  limit: Int
}

type SearchResult {
  entity: Entity
  match: String
}

enum SearchTypes {
  Article
  User
  Tag
}

input SendEmailResetEmailInput {
  email: Email!
}

input SendPasswordResetEmailInput {
  email: Email!
}

input SendVerificationEmailInput {
  email: Email!
}

input SingleFileDeleteInput {
  path: String!
}

input SingleFileUploadInput {
  purpose: String
  file: Upload!
}

input SubscribeArticleInput {
  id: ID!
}

type SubscribedArticleNewCommentNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
  target: Article!
}

type Subscription {
  _: Boolean
  nodeEdited(input: NodeEditedInput!): Node!
}

type Tag implements Node {
  id: ID!
  content: String
  count: Int
  articles(input: ListInput!): [Article]
}

scalar Time

input UnfollowUserInput {
  id: ID!
}

input UnsubscribeArticleInput {
  id: ID!
}

input UpdateNotificationSettingInput {
  type: String!
  enabled: Boolean!
}

input UpdateUserInfoInput {
  displayName: String
  avatar: URL
  description: String
  language: UserLanguage
}

scalar Upload

scalar URL

type User implements Node {
  id: ID!
  info: UserInfo!
  settings: UserSettings!
  recommnedation: Recommendation!

  """Articles written by this user"""
  articles(input: ListInput!): [Article]
  drafts(input: ListInput!): [Draft]
  audioDrafts(input: ListInput!): [AudioDraft]

  """Comments posted by this user"""
  commentedArticles(input: ListInput!): [Article]

  """comments that citated this user's article"""
  citedArticles(input: ListInput!): [Article]
  subscriptions(input: ListInput!): [Article]
  activity: UserActivity!

  """Followers of this user"""
  followers(input: ListInput!): [User]

  """Users that this user follows"""
  followees(input: ListInput!): [User]

  """This user is following viewer"""
  isFollower: Boolean!

  """Viewer is following this user"""
  isFollowee: Boolean!
  status: UserStatus!
  notices(input: ListInput!): [Notice]
}

type UserActivity {
  history(input: ListInput!): [Article]
  recentSearches(input: ListInput!): [String]
  invited(input: ListInput!): [User]
}

type UserDisabledNotice implements Notice {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  reason: UserDisabledReason
}

enum UserDisabledReason {
  violation
}

type UserInfo {
  createdAt: DateTime!

  """Unique user name"""
  userName: String!

  """Display name on profile"""
  displayName: String!

  """User desciption"""
  description: String!

  """URL for avatar"""
  avatar: URL!
  email: Email!
  mobile: String!

  """Use 500 for now, adaptive in the future"""
  readSpeed: Int!
}

enum UserInfoFields {
  displayName
  avatar
  description
  email
  mobile
}

enum UserLanguage {
  en
  zh_hans
  zh_hant
}

input UserLoginInput {
  email: Email!
  password: String!
}

type UserNewFollowerNotice implements Notice & Node {
  id: ID!
  unread: Boolean!
  createdAt: DateTime!
  actors: [User]
}

input UserRegisterInput {
  email: Email!
  displayName: String!
  password: String!
  code: String
}

type UserSettings {
  """User language setting"""
  language: UserLanguage!

  """Thrid party accounts binded for the user"""
  oauthType: [OAuthType]

  """Notification settings"""
  notification: NotificationSetting!
}

type UserStatus {
  currGravity: Int!

  """Total MAT left in wallet"""
  MAT: Int!

  """Number of articles published by user"""
  articleCount: Int!

  """Number of views on articles"""
  viewCount: Int!
  draftCount: Int!

  """Number of comments posted by user"""
  commentCount: Int!
  quotationCount: Int!
  subscriptionCount: Int!

  """Number of user that this user follows"""
  followeeCount: Int!

  """Number of user that follows this user"""
  followerCount: Int!

  """Number of unread notices"""
  unreadNoticeCount: Int!
}

scalar UUID

input VerifyEmailResetCodeInput {
  email: Email!
  code: String!
}

enum Vote {
  up
  down
}
